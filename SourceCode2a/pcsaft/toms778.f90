module L_BFGS_B

!      ALGORITHM 778, COLLECTED ALGORITHMS FROM ACM.
!      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE,
!      VOL. 23,NO. 4,  December, 1997, P.  550--560.

! This version, in a subset of Fortran 90 which is compatible with Lahey's
! ELF90 compiler, is by Alan.Miller @ vic.cmis.csiro.au

! Latest revision - 18 January 1999

  use PARAMETERS, only: dp, machine_eps
  implicit none
  
  real (dp), parameter     :: zero = 0.0_dp, one = 1.0_dp
  real (dp), save          :: dsave(29)
  character (LEN=60), save :: csave
  logical, save            :: lsave(4)
  integer, save            :: isave(23)

  ! The following arrays are allocated in MAINLB on the first call.

  integer, allocatable, dimension(:), save   :: index
  real (dp), allocatable, save :: ws(:,:), wy(:,:), sy(:,:), ss(:,:), wt(:,:), &
       wn(:,:), r(:), t(:)
  integer, allocatable, save   :: iwhere(:)

contains


!================    L-BFGS-B (version 2.3)   ==========================

subroutine mainlb ( n, m, x, l, u, nbd, f, g, factr, pgtol, task, iprint )

integer, intent(IN)                :: n
integer, intent(IN)                :: m
real (dp), intent(IN OUT)          :: x(:)
real (dp), intent(IN)              :: l(:)
real (dp), intent(IN)              :: u(:)
integer, intent(IN)                :: nbd(:)
real (dp), intent(IN OUT)          :: f
real (dp), intent(IN OUT)          :: g(:)
real (dp), intent(IN)              :: factr
real (dp), intent(IN)              :: pgtol
character (LEN=60), intent(IN OUT) :: task
integer, intent(IN)                :: iprint

!     ************

!     Subroutine mainlb

!     This subroutine solves bound constrained optimization problems by
!       using the compact formula of the limited memory BFGS updates.

!     n is an integer variable.
!       On entry n is the number of variables.
!       On exit n is unchanged.

!     m is an integer variable.
!       On entry m is the maximum number of variable metric
!          corrections allowed in the limited memory matrix.
!       On exit m is unchanged.

!     x is a REAL (dp) array of dimension n.
!       On entry x is an approximation to the solution.
!       On exit x is the current approximation.

!     l is a REAL (dp) array of dimension n.
!       On entry l is the lower bound of x.
!       On exit l is unchanged.

!     u is a REAL (dp) array of dimension n.
!       On entry u is the upper bound of x.
!       On exit u is unchanged.

!     nbd is an integer array of dimension n.
!       On entry nbd represents the type of bounds imposed on the
!         variables, and must be specified as follows:
!         nbd(i)=0 if x(i) is unbounded,
!                1 if x(i) has only a lower bound,
!                2 if x(i) has both lower and upper bounds,
!                3 if x(i) has only an upper bound.
!       On exit nbd is unchanged.

!     f is a REAL (dp) variable.
!       On first entry f is unspecified.
!       On final exit f is the value of the function at x.

!     g is a REAL (dp) array of dimension n.
!       On first entry g is unspecified.
!       On final exit g is the value of the gradient at x.

!     factr is a REAL (dp) variable.
!       On entry factr >= 0 is specified by the user.  The iteration
!         will stop when

!         (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch

!         where epsmch is the machine precision, which is automatically
!         generated by the code.
!       On exit factr is unchanged.

!     pgtol is a REAL (dp) variable.
!       On entry pgtol >= 0 is specified by the user.  The iteration
!         will stop when

!                 max{|proj g_i | i = 1, ..., n} <= pgtol

!         where pg_i is the ith component of the projected gradient.
!       On exit pgtol is unchanged.

!     ws, wy, sy, and wt are REAL (dp) working arrays used to store the
!       following information defining the limited memory BFGS matrix:
!          ws, of dimension n x m, stores S, the matrix of s-vectors;
!          wy, of dimension n x m, stores Y, the matrix of y-vectors;
!          sy, of dimension m x m, stores S'Y;
!          ss, of dimension m x m, stores S'S;
!          wt, of dimension m x m, stores the Cholesky factorization of
!                                  (theta*S'S+LD^(-1)L'); see eq.(2.26) in [3].

!     wn is a REAL (dp) working array of dimension 2m x 2m
!       used to store the LEL^T factorization of the indefinite matrix
!                 K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]

!       where     E = [-I  0]
!                     [ 0  I]

!     snd is a REAL (dp) working array of dimension 2m x 2m
!       used to store the lower triangular part of
!                 N = [Y' ZZ'Y   L_a'+R_z']
!                     [L_a +R_z  S'AA'S   ]

!     z(n),r(n),d(n),t(n),wa(8*m) are REAL (dp) working arrays.
!       z is used at different times to store the Cauchy point and
!       the Newton point.

!     index is an integer working array of dimension n.
!       In subroutine freev, index is used to store the free and fixed
!          variables at the Generalized Cauchy Point (GCP).

!     iwhere is an integer working array of dimension n used to record
!       the status of the vector x for GCP computation.
!       iwhere(i)=0 or -3 if x(i) is free and has bounds,
!                 1       if x(i) is fixed at l(i), and l(i) .ne. u(i)
!                 2       if x(i) is fixed at u(i), and u(i) .ne. l(i)
!                 3       if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i)
!                -1       if x(i) is always free, i.e., no bounds on it.

!     indx2 is an integer working array of dimension n.
!       Within subroutine cauchy, indx2 corresponds to the array iorder.
!       In subroutine freev, a list of variables entering and leaving
!       the free set is stored in indx2, and it is passed on to
!       subroutine formk with this information.

!     task is a working string of characters of length 60 indicating
!       the current job when entering and leaving this subroutine.

!     iprint is an INTEGER variable that must be set by the user.
!       It controls the frequency and type of output generated:
!        iprint<0    no output is generated;
!        iprint=0    print only one line at the last iteration;
!        0<iprint<99 print also f and |proj g| every iprint iterations;
!        iprint=99   print details of every iteration except n-vectors;
!        iprint=100  print also the changes of active set and final x;
!        iprint>100  print details of every iteration including x and g;
!       When iprint > 0, the file iterate.dat will be created to
!                        summarize the iteration.

!     csave is a working string of characters of length 60.

!     lsave is a logical working array of dimension 4.
!       On exit with 'task' = NEW_X, the following information is available:
!         If lsave(1) = .true. then  the initial X has been replaced by
!                                    its projection in the feasible set;
!         If lsave(2) = .true. then  the problem is constrained;
!         If lsave(3) = .true. then  each variable has upper and lower bounds;

!     isave is an integer working array of dimension 23.
!       On exit with 'task' = NEW_X, the following information is available:
!         isave(1)  = the total number of intervals explored in the
!                         search of Cauchy points;
!         isave(5)  = the total number of skipped BFGS updates before
!                         the current iteration;
!         isave(9)  = the number of current iteration;
!         isave(10) = the total number of BFGS updates prior the current
!                         iteration;
!         isave(12) = the number of intervals explored in the search of
!                         Cauchy point in the current iteration;
!         isave(13) = the total number of function and gradient
!                         evaluations;
!         isave(15) = the number of function value or gradient
!                         evaluations in the current iteration;
!         if isave(16) = 0  then the subspace argmin is within the box;
!         if isave(16) = 1  then the subspace argmin is beyond the box;
!         isave(17) = the number of free variables in the current iteration;
!         isave(18) = the number of active constraints in the current
!                         iteration;
!         n + 1 - isave(19) = the number of variables leaving the set of
!                           active constraints in the current iteration;
!         isave(20) = the number of variables entering the set of active
!                         constraints in the current iteration.

!     dsave is a REAL (dp) working array of dimension 29.
!       On exit with 'task' = NEW_X, the following information is available:
!         dsave(1) = current 'theta' in the BFGS matrix;
!         dsave(2) = f(x) in the previous iteration;
!         dsave(3) = factr*epsmch;
!         dsave(4) = 2-norm of the line search direction vector;
!         dsave(5) = the machine precision epsmch generated by the code;
!         dsave(7) = the accumulated time spent on searching for Cauchy points;
!         dsave(8) = the accumulated time spent on subspace minimization;
!         dsave(9) = the accumulated time spent on line search;
!         dsave(11) = the slope of the line search function at
!                                  the current point of line search;
!         dsave(12) = the maximum relative step length imposed in line search;
!         dsave(13) = the infinity norm of the projected gradient;
!         dsave(14) = the relative step length in the line search;
!         dsave(15) = the slope of the line search function at
!                                 the starting point of the line search;
!         dsave(16) = the square of the 2-norm of the line search
!                                                      direction vector.

! N.B. Arguments WS, WY, SY, SS, WT, WN, SND, Z, R, D, T, WA, INDEX,
!      IWHERE, INDX2, CSAVE, LSAVE, ISAVE & DSAVE have been removed.

!     Subprograms called

!       L-BFGS-B Library ... cauchy, subsm, lnsrlb, formk,

!        errclb, prn1lb, prn2lb, prn3lb, active, projgr,

!        freev, cmprlb, matupd, formt.

!       Minpack2 Library ... timer, dpmeps.

!       Linpack Library ... dcopy, ddot.

!     References:

!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.

!       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN
!       Subroutines for Large Scale Bound Constrained Optimization''
!       Tech. Report, NAM-11, EECS Department, Northwestern University, 1994.

!       [3] R. Byrd, J. Nocedal and R. Schnabel "Representations of
!       Quasi-Newton Matrices and their use in Limited Memory Methods'',
!       Mathematical Programming 63 (1994), no. 4, pp. 129-156.

!       (Postscript files of these papers are available via anonymous
!        ftp to ece.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)

!                           *  *  *

!     NEOS, November 1994. (Latest revision April 1997.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

real (dp)          :: snd(2*m,2*m), z(n), d(n), wa(8*m)
integer            :: indx2(n)
logical            :: prjctd, cnstnd, boxed, updatd, wrk
character (LEN=3)  :: word
integer            :: k, nintol, itfile, iback, nskip, head, col, iter,  &
                      itail, iupdat, nint, nfgv, info, ifun, iword, nfree,  &
                      nact, ileave, nenter
real (dp)          :: theta, fold, dr, rr, tol, xstep, sbgnrm, &
                      ddum, dnorm, dtd, epsmch, cpu1, cpu2, cachyt, sbtime,  &
                      lnscht, time1, time2, gd, gdold, stp, stpmx, time

if (task == 'START') then
  
  call timer(time1)

!        Allocate work arrays
!        N.B. Arrays may have been already allocated for a different problem

  if (allocated( ws )) deallocate( ws )
  allocate( ws(n,m) )
  if (allocated( wy )) deallocate( wy )
  allocate( wy(n,m) )
  if (allocated( sy )) deallocate( sy )
  allocate( sy(m,m) )
  if (allocated( ss )) deallocate( ss )
  allocate( ss(m,m) )
  if (allocated( wt )) deallocate( wt )
  allocate( wt(m,m) )
  if (allocated( wn )) deallocate( wn )
  allocate( wn(2*m,2*m) )
  if (allocated( r )) deallocate( r )
  allocate( r(n) )
  if (allocated( t )) deallocate( t )
  allocate( t(n) )
  if (allocated( iwhere )) deallocate( iwhere )
  allocate( iwhere(n) )
  if (.NOT.allocated( index )) allocate( index(n) )

!        Generate the current machine precision.
  
  epsmch = epsilon(1.0_dp)
  fold   = 0.0_dp
  dnorm  = 0.0_dp
  cpu1   = 0.0_dp
  gd     = 0.0_dp
  sbgnrm = 0.0_dp
  stp    = 0.0_dp
  stpmx  = 0.0_dp
  gdold  = 0.0_dp
  dtd    = 0.0_dp
  
!        Initialize counters and scalars when task='START'.
  
!           for the limited memory BFGS matrices:
  col    = 0
  head   = 1
  theta  = one
  iupdat = 0
  updatd = .false.
  iback  = 0
  itail  = 0
  ifun   = 0
  iword  = 0
  nact   = 0
  ileave = 0
  nenter = 0
  
!           for operation counts:
  iter   = 0
  nfgv   = 0
  nint   = 0
  nintol = 0
  nskip  = 0
  nfree  = n
  
!           for stopping tolerance:
  tol = factr*epsmch
  
!           for measuring running time:
  cachyt = 0
  sbtime = 0
  lnscht = 0
  
!           'word' records the status of subspace solutions.
  word = '---'
  
!           'info' records the termination information.
  info = 0
  itfile = 0
  
  if (iprint >= 1) then
!                                open a summary file 'iterate.dat'
    open (8, FILE = 'iterate.dat', STATUS = 'unknown')
    itfile = 8
  end if
  
!        Check the input arguments for errors.
  
  call errclb ( n, m, factr, l, u, nbd, task, info, k)
  if (task(1:5) == 'ERROR') then
    call prn3lb ( n, x, f, task, iprint, info, itfile, iter, nfgv, nintol,  &
                  nskip, nact, sbgnrm, zero, nint, word, iback, stp, xstep, &
                  k, cachyt, sbtime, lnscht)
    return
  end if
  
  call prn1lb ( n, m, l, u, x, iprint, itfile, epsmch)
  
!        Initialize iwhere & project x onto the feasible set.
  
  call active ( n, l, u, nbd, x, iwhere, iprint, prjctd, cnstnd, boxed)
  
!        The end of the initialization.
  
else
!          restore local variables.
  
  prjctd = lsave(1)
  cnstnd = lsave(2)
  boxed  = lsave(3)
  updatd = lsave(4)
  
  nintol = isave(1)
  itfile = isave(3)
  iback  = isave(4)
  nskip  = isave(5)
  head   = isave(6)
  col    = isave(7)
  itail  = isave(8)
  iter   = isave(9)
  iupdat = isave(10)
  nint   = isave(12)
  nfgv   = isave(13)
  info   = isave(14)
  ifun   = isave(15)
  iword  = isave(16)
  nfree  = isave(17)
  nact   = isave(18)
  ileave = isave(19)
  nenter = isave(20)
  
  theta  = dsave(1)
  fold   = dsave(2)
  tol    = dsave(3)
  dnorm  = dsave(4)
  epsmch = dsave(5)
  cpu1   = dsave(6)
  cachyt = dsave(7)
  sbtime = dsave(8)
  lnscht = dsave(9)
  time1  = dsave(10)
  gd     = dsave(11)
  stpmx  = dsave(12)
  sbgnrm = dsave(13)
  stp    = dsave(14)
  gdold  = dsave(15)
  dtd    = dsave(16)
  
!        After returning from the driver go to the point where execution
!        is to resume.
  
  if (task(1:5) == 'FG_LN') GO TO 666
  if (task(1:5) == 'NEW_X') GO TO 777
  if (task(1:5) == 'FG_ST') GO TO 111
  if (task(1:4) == 'STOP') then
    if (task(7:9) == 'CPU') then
!                                          restore the previous iterate.
      x(1:n) = t(1:n)
      g(1:n) = r(1:n)
      f = fold
    end if
    GO TO 999
  end if
end if

!     Compute f0 and g0.

task = 'FG_START'
!          return to the driver to calculate f and g; reenter at 111.
GO TO 1000
111 nfgv = 1

!     Compute the infinity norm of the (-) projected gradient.

call projgr ( n, l, u, nbd, x, g, sbgnrm )

if (iprint >= 1) then
  write (6,1002) iter, f, sbgnrm
  write (itfile,1003) iter, nfgv, sbgnrm, f
end if
if (sbgnrm <= pgtol) then
!                                terminate the algorithm.
  task = 'CONVERGENCE: NORM OF PROJECTED GRADIENT <= PGTOL'
  GO TO 999
end if

! ----------------- the beginning of the loop --------------------------

222 if (iprint >= 99) write (6,1001) iter + 1
iword = -1

if (.not. cnstnd .and. col > 0) then
!                                            skip the search for GCP.
  z(1:n) = x(1:n)
  wrk = updatd
  nint = 0
  GO TO 333
end if

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!     Compute the Generalized Cauchy Point (GCP).

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

call timer(cpu1)

call cauchy(n, x, l, u, nbd, g, indx2, iwhere, t, d, z, m, wy, ws, sy, wt,  &
            theta, col, head, wa, wa(2*m+1:), wa(4*m+1:), wa(6*m+1:), nint, &
            iprint, sbgnrm, info, epsmch)

if (info /= 0) then
!         singular triangular system detected; refresh the lbfgs memory.
  if(iprint >= 1) write (6, 1005)
  info   = 0
  col    = 0
  head   = 1
  theta  = one
  iupdat = 0
  updatd = .false.
  call timer(cpu2)
  cachyt = cachyt + cpu2 - cpu1
  GO TO 222
end if
call timer(cpu2)
cachyt = cachyt + cpu2 - cpu1
nintol = nintol + nint

!     Count the entering and leaving variables for iter > 0;
!     find the index set of free and active variables at the GCP.

call freev ( n, nfree, INDEX, nenter, ileave, indx2,  &
           iwhere, wrk, updatd, cnstnd, iprint, iter)

nact = n - nfree

!     If there are no free variables or B=theta*I, then
!                                        skip the subspace minimization.

333 if (nfree == 0 .or. col == 0) GO TO 555

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!     Subspace minimization.

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

call timer(cpu1)

!     Form  the LEL^T factorization of the indefinite
!       matrix    K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]
!       where     E = [-I  0]
!                     [ 0  I]

if (wrk) call formk ( n, nfree, INDEX, nenter, ileave, indx2, iupdat,  &
                    updatd, wn, snd, m, ws, wy, sy, theta, col, head, info)
if (info /= 0) then
!          nonpositive definiteness in Cholesky factorization;
!          refresh the lbfgs memory and restart the iteration.
  if(iprint >= 1) write (6, 1006)
  info   = 0
  col    = 0
  head   = 1
  theta  = one
  iupdat = 0
  updatd = .false.
  call timer(cpu2)
  sbtime = sbtime + cpu2 - cpu1
  GO TO 222
end if

!        compute r=-Z'B(xcp-xk)-Z'g (using wa(2m+1)=W'(xcp-x)
!                                                   from 'cauchy').
call cmprlb(n, m, x, g, ws, wy, sy, wt, z, r, wa, INDEX,  &
            theta, col, head, nfree, cnstnd, info)
if (info /= 0) GO TO 444

!       call the direct method.
call subsm(n, m, nfree, INDEX, l, u, nbd, z, r, ws, wy, theta,  &
           col, head, iword, wa, wn, iprint, info)

444 if (info /= 0) then
!          singular triangular system detected;
!          refresh the lbfgs memory and restart the iteration.
  if(iprint >= 1) write (6, 1005)
  info   = 0
  col    = 0
  head   = 1
  theta  = one
  iupdat = 0
  updatd = .false.
  call timer(cpu2)
  sbtime = sbtime + cpu2 - cpu1
  GO TO 222
end if

call timer(cpu2)
sbtime = sbtime + cpu2 - cpu1

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!     Line search and optimality tests.

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!     Generate the search direction d:=z-x.

555 d(1:n) = z(1:n) - x(1:n)
call timer(cpu1)

666 call lnsrlb ( n, l, u, nbd, x, f, fold, gd, gdold, g, d, r, t, z, stp,  &
                dnorm, dtd, xstep, stpmx, iter, ifun, iback, nfgv, info,  &
                task, boxed, cnstnd, csave, isave(22), dsave(17))

if (info /= 0 .or. iback >= 20) then
!          restore the previous iterate.
  x(1:n) = t(1:n)
  g(1:n) = r(1:n)
  f = fold
  if (col == 0) then
!             abnormal termination.
    if (info == 0) then
      info = -9
!                restore the actual number of f and g evaluations etc.
      nfgv = nfgv - 1
      ifun = ifun - 1
      iback = iback - 1
    end if
    task = 'ABNORMAL_TERMINATION_IN_LNSRCH'
    iter = iter + 1
    GO TO 999
  else
!             refresh the lbfgs memory and restart the iteration.
    if(iprint >= 1) write (6, 1008)
    if (info == 0) nfgv = nfgv - 1
    info   = 0
    col    = 0
    head   = 1
    theta  = one
    iupdat = 0
    updatd = .false.
    task   = 'RESTART_FROM_LNSRCH'
    call timer(cpu2)
    lnscht = lnscht + cpu2 - cpu1
    GO TO 222
  end if
else if (task(1:5) == 'FG_LN') then
!          return to the driver for calculating f and g; reenter at 666.
  GO TO 1000
else
!          calculate and print out the quantities related to the new X.
  call timer(cpu2)
  lnscht = lnscht + cpu2 - cpu1
  iter = iter + 1
  
!        Compute the infinity norm of the projected (-)gradient.
  
  call projgr(n, l, u, nbd, x, g, sbgnrm)
  
!        Print iteration information.
  
  call prn2lb ( n, x, f, g, iprint, itfile, iter, nfgv, nact,  &
              sbgnrm, nint, word, iword, iback, stp, xstep)
  GO TO 1000
end if

!     Test for termination.

777 if (sbgnrm <= pgtol) then
!                                terminate the algorithm.
  task = 'CONVERGENCE: NORM OF PROJECTED GRADIENT <= PGTOL'
  GO TO 999
end if

ddum = max(abs(fold), abs(f), one)
if ((fold - f) <= tol*ddum) then
!                                        terminate the algorithm.
  task = 'CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH'
  if (iback >= 10) info = -5
!           i.e., to issue a warning if iback>10 in the line search.
  GO TO 999
end if

!     Compute d=newx-oldx, r=newg-oldg, rr=y'y and dr=y's.

r(1:n) = g(1:n) - r(1:n)
rr = sum( r(1:n)**2 )
if ( abs( stp - one ) < machine_eps ) then
  dr = gd - gdold
  ddum = -gdold
else
  dr = (gd - gdold)*stp
  d(1:n) = stp*d(1:n)
  ddum = -gdold*stp
end if

if (dr <= epsmch*ddum) then
!                            skip the L-BFGS update.
  nskip = nskip + 1
  updatd = .false.
  if (iprint >= 1) write (6,1004) dr, ddum
  GO TO 888
end if

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!     Update the L-BFGS matrix.

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

updatd = .true.
iupdat = iupdat + 1

!     Update matrices WS and WY and form the middle matrix in B.

call matupd ( n, m, ws, wy, sy, ss, d, r, itail, iupdat, col, head, theta, rr, &
            dr, stp, dtd)

!     Form the upper half of the pds T = theta*SS + L*D^(-1)*L';
!        Store T in the upper triangular of the array wt;
!        Cholesky factorize T to J*J' with
!           J' stored in the upper triangular of wt.

call formt ( wt, sy, ss, col, theta, info)

if (info /= 0) then
!          nonpositive definiteness in Cholesky factorization;
!          refresh the lbfgs memory and restart the iteration.
  if(iprint >= 1) write (6, 1007)
  info = 0
  col = 0
  head = 1
  theta = one
  iupdat = 0
  updatd = .false.
  GO TO 222
end if

!     Now the inverse of the middle matrix in B is

!       [  D^(1/2)      O ] [ -D^(1/2)  D^(-1/2)*L' ]
!       [ -L*D^(-1/2)   J ] [  0        J'          ]

! -------------------- the end of the loop -----------------------------

888 GO TO 222

999 call timer(time2)
time = time2 - time1
call prn3lb ( n, x, f, task, iprint, info, itfile, iter, nfgv, nintol, nskip, &
            nact, sbgnrm, time, nint, word, iback, stp, xstep, k, cachyt,   &
            sbtime, lnscht)

!     Save local variables.

1000 lsave(1)  = prjctd
lsave(2)  = cnstnd
lsave(3)  = boxed
lsave(4)  = updatd

isave(1)  = nintol
isave(3)  = itfile
isave(4)  = iback
isave(5)  = nskip
isave(6)  = head
isave(7)  = col
isave(8)  = itail
isave(9)  = iter
isave(10) = iupdat
isave(12) = nint
isave(13) = nfgv
isave(14) = info
isave(15) = ifun
isave(16) = iword
isave(17) = nfree
isave(18) = nact
isave(19) = ileave
isave(20) = nenter

dsave(1)  = theta
dsave(2)  = fold
dsave(3)  = tol
dsave(4)  = dnorm
dsave(5)  = epsmch
dsave(6)  = cpu1
dsave(7)  = cachyt
dsave(8)  = sbtime
dsave(9)  = lnscht
dsave(10) = time1
dsave(11) = gd
dsave(12) = stpmx
dsave(13) = sbgnrm
dsave(14) = stp
dsave(15) = gdold
dsave(16) = dtd

1001 format (//' ITERATION ', i5)
1002 format (/ ' At iterate', i5, '   f = ',g13.5, '    |proj g|= ', g13.5)
1003 format (2(' ', i4), '     -     -   -     -     -          -   ',  &
             2('  ', g11.3))
1004 format ('  ys = ', e10.3, '  -gs = ', e10.3, ' BFGS update SKIPPED')
1005 format (/ ' Singular triangular system detected;',/,  &
             '   refresh the lbfgs memory and restart the iteration.')
1006 format (/  &
             ' Nonpositive definiteness in Cholesky factorization in formk;'/ &
             '   refresh the lbfgs memory and restart the iteration.')
1007 format (/  &
             ' Nonpositive definiteness in Cholesky factorization in formt;'/ &
             '   refresh the lbfgs memory and restart the iteration.')
1008 format (/ ' Bad direction in the line search;'/  &
             '   refresh the lbfgs memory and restart the iteration.')

return

end subroutine mainlb

!======================= The end of mainlb =============================

subroutine active ( n, l, u, nbd, x, iwhere, iprint, prjctd, cnstnd, boxed)

integer, intent(IN)        :: n
real (dp), intent(IN)      :: l(:)
real (dp), intent(IN)      :: u(:)
integer, intent(IN)        :: nbd(:)
real (dp), intent(IN OUT)  :: x(:)
integer, intent(OUT)       :: iwhere(:)
integer, intent(IN)        :: iprint
logical, intent(OUT)       :: prjctd
logical, intent(OUT)       :: cnstnd
logical, intent(OUT)       :: boxed

!     ************

!     Subroutine active

!     This subroutine initializes iwhere and projects the initial x to
!       the feasible set if necessary.

!     iwhere is an integer array of dimension n.
!       On entry iwhere is unspecified.
!       On exit iwhere(i)=-1  if x(i) has no bounds
!                         3   if l(i)=u(i)
!                         0   otherwise.
!       In cauchy, iwhere is given finer gradations.

!                           *  *  *

!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

integer :: nbdd, i

!     Initialize nbdd, prjctd, cnstnd and boxed.

nbdd = 0
prjctd = .false.
cnstnd = .false.
boxed = .true.

!     Project the initial x to the easible set if necessary.

do i = 1, n
  if (nbd(i) > 0) then
    if (nbd(i) <= 2 .and. x(i) <= l(i)) then
      if (x(i) < l(i)) then
        prjctd = .true.
        x(i) = l(i)
      end if
      nbdd = nbdd + 1
    else if (nbd(i) >= 2 .and. x(i) >= u(i)) then
      if (x(i) > u(i)) then
        prjctd = .true.
        x(i) = u(i)
      end if
      nbdd = nbdd + 1
    end if
  end if
end do

!     Initialize iwhere and assign values to cnstnd and boxed.

do i = 1, n
  if (nbd(i) /= 2) boxed = .false.
  if (nbd(i) == 0) then
!                                this variable is always free
    iwhere(i) = -1
    
!           otherwise set x(i)=mid(x(i), u(i), l(i)).
  else
    cnstnd = .true.
    if (nbd(i) == 2 .and. u(i) - l(i) <= zero) then
!                   this variable is always fixed
      iwhere(i) = 3
    else
      iwhere(i) = 0
    end if
  end if
end do

if (iprint >= 0) then
  if (prjctd) write (6,*)  &
      'The initial X is infeasible.  Restart with its projection.'
  if (.not. cnstnd) write (6,*) 'This problem is unconstrained.'
end if

if (iprint > 0) write (6,1001) nbdd

1001 format (/ ' At X0 ', i9, ' variables are exactly at the bounds')

return

end subroutine active

!======================= The end of active =============================

subroutine bmv ( sy, wt, col, v, p, info)

real (dp), intent(IN)   :: sy(:, :)   ! sy(m, m)
real (dp), intent(IN)   :: wt(:, :)   ! wt(m, m)
integer, intent(IN)     :: col
real (dp), intent(IN)   :: v(:)
real (dp), intent(OUT)  :: p(:)
integer, intent(OUT)    :: info

!     ************

!     Subroutine bmv

!     This subroutine computes the product of the 2m x 2m middle matrix
!       in the compact L-BFGS formula of B and a 2m vector v;
!       it returns the product in p.

!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.

!     sy is a REAL (dp) array of dimension m x m.
!       On entry sy specifies the matrix S'Y.
!       On exit sy is unchanged.

!     wt is a REAL (dp) array of dimension m x m.
!       On entry wt specifies the upper triangular matrix J' which is
!         the Cholesky factor of (thetaS'S+LD^(-1)L').
!       On exit wt is unchanged.

!     col is an integer variable.
!       On entry col specifies the number of s-vectors (or y-vectors)
!         stored in the compact L-BFGS formula.
!       On exit col is unchanged.

!     v is a REAL (dp) array of dimension 2col.
!       On entry v specifies vector v.
!       On exit v is unchanged.

!     p is a REAL (dp) array of dimension 2col.
!       On entry p is unspecified.
!       On exit p is the product Mv.

!     info is an integer variable.
!       On entry info is unspecified.
!       On exit info = 0       for normal return,
!                    = nonzero for abnormal return when the system
!                                to be solved by dtrsl is singular.

! N.B. Argument M has been removed.

!     Subprograms called:

!       Linpack ... dtrsl.

!                           *  *  *

!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

integer   :: i, k, i2
real (dp) :: sum

if (col == 0) return

!     PART I: solve [  D^(1/2)      O ] [ p1 ] = [ v1 ]
!                   [ -L*D^(-1/2)   J ] [ p2 ]   [ v2 ].

!       solve Jp2=v2+LD^(-1)v1.
p(col + 1) = v(col + 1)
do i = 2, col
  i2 = col + i
  sum = 0.0_dp
  do k = 1, i - 1
    sum = sum + sy(i,k)*v(k)/sy(k,k)
  end do
  p(i2) = v(i2) + sum
end do
!     Solve the triangular system
call dtrsl ( wt, col, p(col+1:), 11, info)
if (info /= 0) return

!       solve D^(1/2)p1=v1.
do i = 1, col
  p(i) = v(i)/sqrt(sy(i,i))
end do

!     PART II: solve [ -D^(1/2)   D^(-1/2)*L'  ] [ p1 ] = [ p1 ]
!                    [  0         J'           ] [ p2 ]   [ p2 ].

!       solve J^Tp2=p2.
call dtrsl ( wt, col, p(col+1:), 01, info)
if (info /= 0) return

!       compute p1=-D^(-1/2)(p1-D^(-1/2)L'p2)
!                 =-D^(-1/2)p1+D^(-1)L'p2.
do i = 1, col
  p(i) = -p(i)/sqrt(sy(i,i))
end do
do i = 1, col
  sum = 0._dp
  do k = i + 1, col
    sum = sum + sy(k,i)*p(col+k)/sy(i,i)
  end do
  p(i) = p(i) + sum
end do

return

end subroutine bmv

!======================== The end of bmv ===============================

subroutine cauchy ( n, x, l, u, nbd, g, iorder, iwhere, t, d, xcp,  &
                    m, wy, ws, sy, wt, theta, col, head, p, c, wbp,  &
                    v, nint, iprint, sbgnrm, info, epsmch)

integer, intent(IN)        :: n
real (dp), intent(IN)      :: x(:)
real (dp), intent(IN)      :: l(:)
real (dp), intent(IN)      :: u(:)
integer, intent(IN)        :: nbd(:)
real (dp), intent(IN)      :: g(:)
integer, intent(OUT)       :: iorder(:)
integer, intent(IN OUT)    :: iwhere(:)
real (dp), intent(OUT)     :: t(:)
real (dp), intent(OUT)     :: d(:)
real (dp), intent(OUT)     :: xcp(:)
integer, intent(IN)        :: m
real (dp), intent(IN)      :: wy(:, :)   ! wy(n, col)
real (dp), intent(IN)      :: ws(:, :)   ! ws(n, col)
real (dp), intent(IN)      :: sy(:, :)   ! sy(m, m)
real (dp), intent(IN)      :: wt(:, :)   ! wt(m, m)
real (dp), intent(IN)      :: theta
integer, intent(IN)        :: col
integer, intent(IN)        :: head
real (dp), intent(OUT)     :: p(:)
real (dp), intent(OUT)     :: c(:)
real (dp), intent(OUT)     :: wbp(:)
real (dp), intent(OUT)     :: v(:)
integer, intent(OUT)       :: nint
integer, intent(IN)        :: iprint
real (dp), intent(IN OUT)  :: sbgnrm
integer, intent(IN OUT)    :: info
real (dp), intent(IN)      :: epsmch

!     ************

!     Subroutine cauchy

!     For given x, l, u, g (with sbgnrm > 0), and a limited memory BFGS matrix
!       B defined in terms of matrices WY, WS, WT, and scalars head, col, and
!       theta, this subroutine computes the generalized Cauchy point (GCP),
!       defined as the first local minimizer of the quadratic

!                  Q(x + s) = g's + 1/2 s'Bs

!       along the projected gradient direction P(x-tg,l,u).
!       The routine returns the GCP in xcp.

!     n is an integer variable.
!       On entry n is the dimension of the problem.
!       On exit n is unchanged.

!     x is a REAL (dp) array of dimension n.
!       On entry x is the starting point for the GCP computation.
!       On exit x is unchanged.

!     l is a REAL (dp) array of dimension n.
!       On entry l is the lower bound of x.
!       On exit l is unchanged.

!     u is a REAL (dp) array of dimension n.
!       On entry u is the upper bound of x.
!       On exit u is unchanged.

!     nbd is an integer array of dimension n.
!       On entry nbd represents the type of bounds imposed on the
!         variables, and must be specified as follows:
!         nbd(i)=0 if x(i) is unbounded,
!                1 if x(i) has only a lower bound,
!                2 if x(i) has both lower and upper bounds, and
!                3 if x(i) has only an upper bound.
!       On exit nbd is unchanged.

!     g is a REAL (dp) array of dimension n.
!       On entry g is the gradient of f(x).  g must be a nonzero vector.
!       On exit g is unchanged.

!     iorder is an integer working array of dimension n.
!       iorder will be used to store the breakpoints in the piecewise
!       linear path and free variables encountered.  On exit,
!         iorder(1),...,iorder(nleft) are indices of breakpoints
!                                which have not been encountered;
!         iorder(nleft+1),...,iorder(nbreak) are indices of
!                                     encountered breakpoints; and
!         iorder(nfree),...,iorder(n) are indices of variables which
!                 have no bound constraints along the search direction.

!     iwhere is an integer array of dimension n.
!       On entry iwhere indicates only the permanently fixed (iwhere=3)
!       or free (iwhere= -1) components of x.
!       On exit iwhere records the status of the current x variables.
!       iwhere(i)=-3  if x(i) is free and has bounds, but is not moved
!                 0   if x(i) is free and has bounds, and is moved
!                 1   if x(i) is fixed at l(i), and l(i) .ne. u(i)
!                 2   if x(i) is fixed at u(i), and u(i) .ne. l(i)
!                 3   if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i)
!                 -1  if x(i) is always free, i.e., it has no bounds.

!     t is a REAL (dp) working array of dimension n.
!       t will be used to store the break points.

!     d is a REAL (dp) array of dimension n used to store
!       the Cauchy direction P(x-tg)-x.

!     xcp is a REAL (dp) array of dimension n used to return the GCP on exit.

!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.

!     ws, wy, sy, and wt are REAL (dp) arrays.
!       On entry they store information that defines the
!                             limited memory BFGS matrix:
!         ws(n,m) stores S, a set of s-vectors;
!         wy(n,m) stores Y, a set of y-vectors;
!         sy(m,m) stores S'Y;
!         wt(m,m) stores the
!                 Cholesky factorization of (theta*S'S+LD^(-1)L').
!       On exit these arrays are unchanged.

!     theta is a REAL (dp) variable.
!       On entry theta is the scaling factor specifying B_0 = theta I.
!       On exit theta is unchanged.

!     col is an integer variable.
!       On entry col is the actual number of variable metric
!         corrections stored so far.
!       On exit col is unchanged.

!     head is an integer variable.
!       On entry head is the location of the first s-vector
!         (or y-vector) in S (or Y).
!       On exit col is unchanged.

!     p is a REAL (dp) working array of dimension 2m.
!       p will be used to store the vector p = W^(T)d.

!     c is a REAL (dp) working array of dimension 2m.
!       c will be used to store the vector c = W^(T)(xcp-x).

!     wbp is a REAL (dp) working array of dimension 2m.
!       wbp will be used to store the row of W corresponding to a breakpoint.

!     v is a REAL (dp) working array of dimension 2m.

!     nint is an integer variable.
!       On exit nint records the number of quadratic segments explored
!         in searching for the GCP.

!     iprint is an INTEGER variable that must be set by the user.
!       It controls the frequency and type of output generated:
!        iprint<0    no output is generated;
!        iprint=0    print only one line at the last iteration;
!        0<iprint<99 print also f and |proj g| every iprint iterations;
!        iprint=99   print details of every iteration except n-vectors;
!        iprint=100  print also the changes of active set and final x;
!        iprint>100  print details of every iteration including x and g;
!       When iprint > 0, the file iterate.dat will be created to
!                        summarize the iteration.

!     sbgnrm is a REAL (dp) variable.
!       On entry sbgnrm is the norm of the projected gradient at x.
!       On exit sbgnrm is unchanged.

!     info is an integer variable.
!       On entry info is 0.
!       On exit info = 0       for normal return,
!                    = nonzero for abnormal return when the the system
!                              used in routine bmv is singular.

!     Subprograms called:

!       L-BFGS-B Library ... hpsolb, bmv.

!       Linpack ... dscal dcopy, daxpy.

!     References:

!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.

!       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN
!       Subroutines for Large Scale Bound Constrained Optimization''
!       Tech. Report, NAM-11, EECS Department, Northwestern University, 1994.

!       (Postscript files of these papers are available via anonymous
!        ftp to ece.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)

!                           *  *  *

!     NEOS, November 1994. (Latest revision April 1997.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

logical   :: xlower, xupper, bnded
integer   :: i, j, col2, nfree, nbreak, pointr, ibp, nleft, ibkmin, iter
real (dp) :: f1, f2, dt, dtm, tsum, dibp, zibp, dibp2, bkmin,  &
             tu, tl, wmc, wmp, wmw, tj, tj0, neggi, f2_org

!     Check the status of the variables, reset iwhere(i) if necessary;
!       compute the Cauchy direction d and the breakpoints t; initialize
!       the derivative f1 and the vector p = W'd (for theta = 1).

if (sbgnrm <= zero) then
  if (iprint >= 0) write (6,*) 'subgnorm = 0.  GCP = X.'
  xcp(1:n) = x(1:n)
  return
end if
bnded = .true.
nfree = n + 1
nbreak = 0
ibkmin = 0
bkmin = zero
col2 = 2*col
f1 = zero
if (iprint >= 99) write (6,3010)

!     We set p to zero and build it up as we determine d.

p(1:col2) = zero

!     In the following loop we determine for each variable its bound
!        status and its breakpoint, and update p accordingly.
!        Smallest breakpoint is identified.

do i = 1, n
  neggi = -g(i)
  if (iwhere(i) /= 3 .and. iwhere(i) /= -1) then
!             if x(i) is not a constant and has bounds,
!             compute the difference between x(i) and its bounds.
    if (nbd(i) <= 2) tl = x(i) - l(i)
    if (nbd(i) >= 2) tu = u(i) - x(i)
    
!           If a variable is close enough to a bound
!             we treat it as at bound.
    xlower = nbd(i) <= 2 .and. tl <= zero
    xupper = nbd(i) >= 2 .and. tu <= zero
    
!              reset iwhere(i).
    iwhere(i) = 0
    if (xlower) then
      if (neggi <= zero) iwhere(i) = 1
    else if (xupper) then
      if (neggi >= zero) iwhere(i) = 2
    else
      if (abs(neggi) <= zero) iwhere(i) = -3
    end if
  end if
  pointr = head
  if (iwhere(i) /= 0 .and. iwhere(i) /= -1) then
    d(i) = zero
  else
    d(i) = neggi
    f1 = f1 - neggi*neggi
!             calculate p := p - W'e_i* (g_i).
    do j = 1, col
      p(j) = p(j) +  wy(i,pointr)* neggi
      p(col + j) = p(col + j) + ws(i,pointr)*neggi
      pointr = mod(pointr,m) + 1
    end do
    if (nbd(i) <= 2 .and. nbd(i) /= 0 .and. neggi < zero) then
!                                 x(i) + d(i) is bounded; compute t(i).
      nbreak = nbreak + 1
      iorder(nbreak) = i
      t(nbreak) = tl/(-neggi)
      if (nbreak == 1 .or. t(nbreak) < bkmin) then
        bkmin = t(nbreak)
        ibkmin = nbreak
      end if
    else if (nbd(i) >= 2 .and. neggi > zero) then
!                                 x(i) + d(i) is bounded; compute t(i).
      nbreak = nbreak + 1
      iorder(nbreak) = i
      t(nbreak) = tu/neggi
      if (nbreak == 1 .or. t(nbreak) < bkmin) then
        bkmin = t(nbreak)
        ibkmin = nbreak
      end if
    else
!                x(i) + d(i) is not bounded.
      nfree = nfree - 1
      iorder(nfree) = i
      if (abs(neggi) > zero) bnded = .false.
    end if
  end if
end do

!     The indices of the nonzero components of d are now stored
!       in iorder(1),...,iorder(nbreak) and iorder(nfree),...,iorder(n).
!       The smallest of the nbreak breakpoints is in t(ibkmin)=bkmin.

if ( abs( theta - one ) > machine_eps ) then
!                   complete the initialization of p for theta not = one.
  p(col+1:col+col) = theta*p(col+1:col+col)
end if

!     Initialize GCP xcp = x.

xcp(1:n) = x(1:n)

if (nbreak == 0 .and. nfree == n + 1) then
!                  is a zero vector, return with the initial xcp as GCP.
  if (iprint > 100) write (6,1010) xcp(1:n)
  return
end if

!     Initialize c = W'(xcp - x) = 0.

c(1:col2) = zero

!     Initialize derivative f2.

f2 = -theta*f1
f2_org = f2
if (col > 0) then
  call bmv ( sy, wt, col, p, v, info)
  if (info /= 0) return
  f2 = f2 - DOT_product( v(1:col2), p(1:col2) )
end if
dtm = -f1/f2
tsum = zero
nint = 1
if (iprint >= 99) write (6,*) 'There are ', nbreak, '  breakpoints '

!     If there are no breakpoints, locate the GCP and return.

if (nbreak == 0) GO TO 888

nleft = nbreak
iter = 1

tj = zero

!------------------- the beginning of the loop -------------------------

!     Find the next smallest breakpoint;
!       compute dt = t(nleft) - t(nleft + 1).

777 tj0 = tj
if (iter == 1) then
!         Since we already have the smallest breakpoint we need not do
!         heapsort yet. Often only one breakpoint is used and the
!         cost of heapsort is avoided.
  tj = bkmin
  ibp = iorder(ibkmin)
else
  if (iter == 2) then
!             Replace the already used smallest breakpoint with the
!             breakpoint numbered nbreak > nlast, before heapsort call.
    if (ibkmin /= nbreak) then
      t(ibkmin) = t(nbreak)
      iorder(ibkmin) = iorder(nbreak)
    end if
!        Update heap structure of breakpoints
!           (if iter=2, initialize heap).
  end if
  call hpsolb ( nleft, t, iorder, iter-2)
  tj = t(nleft)
  ibp = iorder(nleft)
end if

dt = tj - tj0

if ( abs( dt ) > machine_eps .and. iprint >= 100) then
  write (6,4011) nint, f1, f2
  write (6,5010) dt
  write (6,6010) dtm
end if

!     If a minimizer is within this interval,
!       locate the GCP and return.

if (dtm < dt) GO TO 888

!     Otherwise fix one variable and
!       reset the corresponding component of d to zero.

tsum = tsum + dt
nleft = nleft - 1
iter = iter + 1
dibp = d(ibp)
d(ibp) = zero
if (dibp > zero) then
  zibp = u(ibp) - x(ibp)
  xcp(ibp) = u(ibp)
  iwhere(ibp) = 2
else
  zibp = l(ibp) - x(ibp)
  xcp(ibp) = l(ibp)
  iwhere(ibp) = 1
end if
if (iprint >= 100) write (6,*) 'variable  ',ibp,'  is fixed.'
if (nleft == 0 .and. nbreak == n) then
!                                             all n variables are fixed,
!                                                return with xcp as GCP.
  dtm = dt
  GO TO 999
end if

!     Update the derivative information.

nint = nint + 1
dibp2 = dibp**2

!     Update f1 and f2.

!        temporarily set f1 and f2 for col=0.
f1 = f1 + dt*f2 + dibp2 - theta*dibp*zibp
f2 = f2 - theta*dibp2

if (col > 0) then
!                          update c = c + dt*p.
  c(1:col2) = c(1:col2) + dt*p(1:col2)
  
!           choose wbp,
!           the row of W corresponding to the breakpoint encountered.
  pointr = head
  do j = 1,col
    wbp(j) = wy(ibp,pointr)
    wbp(col + j) = theta*ws(ibp,pointr)
    pointr = mod(pointr,m) + 1
  end do
  
!           compute (wbp)Mc, (wbp)Mp, and (wbp)M(wbp)'.
  call bmv ( sy, wt, col, wbp, v, info)
  if (info /= 0) return
  wmc = DOT_product( c(1:col2), v(1:col2) )
  wmp = DOT_product( p(1:col2), v(1:col2) )
  wmw = DOT_product( wbp(1:col2), v(1:col2) )
  
!           update p = p - dibp*wbp.
  p(1:col2) = p(1:col2) - dibp*wbp(1:col2)
  
!           complete updating f1 and f2 while col > 0.
  f1 = f1 + dibp*wmc
  f2 = f2 + 2.0_dp*dibp*wmp - dibp2*wmw
end if

f2 = max(epsmch*f2_org,f2)
if (nleft > 0) then
  dtm = -f1/f2
  GO TO 777
!                 to repeat the loop for unsearched intervals.
else if(bnded) then
  f1 = zero
  f2 = zero
  dtm = zero
else
  dtm = -f1/f2
end if

!------------------- the end of the loop -------------------------------

888 if (iprint >= 99) then
  write (6,*)
  write (6,*) 'GCP found in this segment'
  write (6,4010) nint, f1, f2
  write (6,6010) dtm
end if
if (dtm <= zero) dtm = zero
tsum = tsum + dtm

!     Move free variables (i.e., the ones w/o breakpoints) and
!       the variables whose breakpoints haven't been reached.

xcp(1:n) = xcp(1:n) + tsum*d(1:n)

!     Update c = c + dtm*p = W'(x^c - x)
!       which will be used in computing r = Z'(B(x^c - x) + g).

999 if (col > 0) c(1:col2) = c(1:col2) + dtm*p(1:col2)
if (iprint > 100) write (6,1010) xcp(1:n)
if (iprint >= 99) write (6,2010)

1010 format (' Cauchy X =  '/ ('    ', 6(' ', g12.4)))
2010 format (/ ' ---------------- exit CAUCHY----------------------',/)
3010 format (/ ' ---------------- CAUCHY entered-------------------')
4010 format (' Piece    ', i3, ' --f1, f2 at start point ', 2(' ', g12.4))
4011 format (/ 'Piece    ', i3, ' --f1, f2 at start point ', 2(' ', g12.4))
5010 format (' Distance to the next break point =  ', g12.4)
6010 format (' Distance to the stationary point =  ', g12.4)

return

end subroutine cauchy

!====================== The end of cauchy ==============================

subroutine cmprlb ( n, m, x, g, ws, wy, sy, wt, z, r, wa, INDEX,  &
                  theta, col, head, nfree, cnstnd, info)

integer, intent(IN)        :: n
integer, intent(IN)        :: m
real (dp), intent(IN)      :: x(:)
real (dp), intent(IN)      :: g(:)
real (dp), intent(IN)      :: ws(:, :)    ! ws(n, m)
real (dp), intent(IN)      :: wy(:, :)    ! wy(n, m)
real (dp), intent(IN OUT)  :: sy(:, :)    ! sy(m, m)
real (dp), intent(IN OUT)  :: wt(:, :)    ! wt(m, m)
real (dp), intent(IN OUT)  :: z(:)
real (dp), intent(OUT)     :: r(:)
real (dp), intent(IN OUT)  :: wa(:)
integer, intent(IN)        :: index(:)
real (dp), intent(IN)      :: theta
integer, intent(IN)        :: col
integer, intent(IN)        :: head
integer, intent(IN)        :: nfree
logical, intent(IN)        :: cnstnd
integer, intent(OUT)       :: info

!     ************

!     Subroutine cmprlb

!       This subroutine computes r=-Z'B(xcp-xk)-Z'g by using
!         wa(2m+1)=W'(xcp-x) from subroutine cauchy.

!     Subprograms called:

!       L-BFGS-B Library ... bmv.

!                           *  *  *

!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

integer   :: i, j, k, pointr
real (dp) :: a1, a2

if (.not. cnstnd .and. col > 0) then
  r(1:n) = -g(1:n)
else
  do i = 1, nfree
    k = index(i)
    r(i) = -theta*(z(k) - x(k)) - g(k)
  end do
  call bmv ( sy, wt, col, wa(2*m+1:), wa, info)
  if (info /= 0) then
    info = -8
    return
  end if
  pointr = head
  do j = 1, col
    a1 = wa(j)
    a2 = theta*wa(col + j)
    do i = 1, nfree
      k = index(i)
      r(i) = r(i) + wy(k,pointr)*a1 + ws(k,pointr)*a2
    end do
    pointr = mod(pointr,m) + 1
  end do
end if

return

end subroutine cmprlb

!======================= The end of cmprlb =============================

subroutine errclb ( n, m, factr, l, u, nbd, task, info, k)

integer, intent(IN)              :: n
integer, intent(IN)              :: m
real (dp), intent(IN)            :: factr
real (dp), intent(IN)            :: l(:)
real (dp), intent(IN)            :: u(:)
integer, intent(IN)              :: nbd(:)
character (LEN=60), intent(OUT)  :: task
integer, intent(OUT)             :: info
integer, intent(OUT)             :: k

!     ************

!     Subroutine errclb

!     This subroutine checks the validity of the input data.

!                           *  *  *

!     NEOS, November 1994. (Latest revision April 1997.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

integer :: i

!     Check the input arguments for errors.

if (n <= 0) task = 'ERROR: N .LE. 0'
if (m <= 0) task = 'ERROR: M .LE. 0'
if (factr < zero) task = 'ERROR: FACTR .LT. 0'

!     Check the validity of the arrays nbd(i), u(i), and l(i).

do i = 1, n
  if (nbd(i) < 0 .or. nbd(i) > 3) then
!                                                   return
    task = 'ERROR: INVALID NBD'
    info = -6
    k = i
  end if
  if (nbd(i) == 2) then
    if (l(i) > u(i)) then
!                                    return
      task = 'ERROR: NO FEASIBLE SOLUTION'
      info = -7
      k = i
    end if
  end if
end do

return

end subroutine errclb

!======================= The end of errclb =============================

subroutine formk ( n, nsub, ind, nenter, ileave, indx2, iupdat,  &
                 updatd, wn, wn1, m, ws, wy, sy, theta, col, head, info)

integer, intent(IN)      :: n
integer, intent(IN)      :: nsub
integer, intent(IN)      :: ind(:)
integer, intent(IN)      :: nenter
integer, intent(IN)      :: ileave
integer, intent(IN)      :: indx2(:)
integer, intent(IN OUT)  :: iupdat
logical, intent(IN OUT)  :: updatd
real (dp), intent(OUT)   :: wn(:, :)    ! wn(2*m, 2*m)
real (dp), intent(OUT)   :: wn1(:, :)   ! wn1(2*m, 2*m)
integer, intent(IN)      :: m
real (dp), intent(IN)    :: ws(:, :)    ! ws(n, m)
real (dp), intent(IN)    :: wy(:, :)    ! wy(n, m)
real (dp), intent(IN)    :: sy(:, :)    ! sy(m, m)
real (dp), intent(IN)    :: theta
integer, intent(IN)      :: col
integer, intent(IN)      :: head
integer, intent(OUT)     :: info

!     ************

!     Subroutine formk

!     This subroutine forms  the LEL^T factorization of the indefinite

!       matrix    K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]
!                                                    where E = [-I  0]
!                                                              [ 0  I]
!     The matrix K can be shown to be equal to the matrix M^[-1]N
!       occurring in section 5.1 of [1], as well as to the matrix
!       Mbar^[-1] Nbar in section 5.3.

!     n is an integer variable.
!       On entry n is the dimension of the problem.
!       On exit n is unchanged.

!     nsub is an integer variable
!       On entry nsub is the number of subspace variables in free set.
!       On exit nsub is not changed.

!     ind is an integer array of dimension nsub.
!       On entry ind specifies the indices of subspace variables.
!       On exit ind is unchanged.

!     nenter is an integer variable.
!       On entry nenter is the number of variables entering the free set.
!       On exit nenter is unchanged.

!     ileave is an integer variable.
!       On entry indx2(ileave),...,indx2(n) are the variables leaving the
!         free set.
!       On exit ileave is unchanged.

!     indx2 is an integer array of dimension n.
!       On entry indx2(1),...,indx2(nenter) are the variables entering
!         the free set, while indx2(ileave),...,indx2(n) are the
!         variables leaving the free set.
!       On exit indx2 is unchanged.

!     iupdat is an integer variable.
!       On entry iupdat is the total number of BFGS updates made so far.
!       On exit iupdat is unchanged.

!     updatd is a logical variable.
!       On entry 'updatd' is true if the L-BFGS matrix is updatd.
!       On exit 'updatd' is unchanged.

!     wn is a REAL (dp) array of dimension 2m x 2m.
!       On entry wn is unspecified.
!       On exit the upper triangle of wn stores the LEL^T factorization
!         of the 2*col x 2*col indefinite matrix
!                     [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]

!     wn1 is a REAL (dp) array of dimension 2m x 2m.
!       On entry wn1 stores the lower triangular part of
!                     [Y' ZZ'Y   L_a'+R_z']
!                     [L_a+R_z   S'AA'S   ]
!         in the previous iteration.
!       On exit wn1 stores the corresponding updated matrices.
!       The purpose of wn1 is just to store these inner products
!       so they can be easily updated and inserted into wn.

!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.

!     ws, wy, sy, and wtyy are REAL (dp) arrays;
!     theta is a REAL (dp) variable;
!     col is an integer variable;
!     head is an integer variable.
!       On entry they store the information defining the
!                                          limited memory BFGS matrix:
!         ws(n,m) stores S, a set of s-vectors;
!         wy(n,m) stores Y, a set of y-vectors;
!         sy(m,m) stores S'Y;
!         wtyy(m,m) stores the Cholesky factorization
!                                   of (theta*S'S+LD^(-1)L')
!         theta is the scaling factor specifying B_0 = theta I;
!         col is the number of variable metric corrections stored;
!         head is the location of the 1st s- (or y-) vector in S (or Y).
!       On exit they are unchanged.

!     info is an integer variable.
!       On entry info is unspecified.
!       On exit info =  0 for normal return;
!                    = -1 when the 1st Cholesky factorization failed;
!                    = -2 when the 2st Cholesky factorization failed.

!     Subprograms called:

!       Linpack ... dcopy, dpofa, dtrsl.


!     References:
!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.

!       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a
!       limited memory FORTRAN code for solving bound constrained
!       optimization problems'', Tech. Report, NAM-11, EECS Department,
!       Northwestern University, 1994.

!       (Postscript files of these papers are available via anonymous
!        ftp to ece.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)

!                           *  *  *

!     NEOS, November 1994. (Latest revision April 1997.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

integer   :: ipntr, jpntr, iy, is, jy, js, is1, js1, k1, i, k,  &
             col2, pbegin, pend, dbegin, dend, upcl
real (dp) :: temp1, temp2, temp3, temp4

!     Form the lower triangular part of
!               WN1 = [Y' ZZ'Y   L_a'+R_z']
!                     [L_a+R_z   S'AA'S   ]
!        where L_a is the strictly lower triangular part of S'AA'Y
!              R_z is the upper triangular part of S'ZZ'Y.

if (updatd) then
  if (iupdat > m) then
!                                 shift old part of WN1.
    do jy = 1, m - 1
      js = m + jy
      wn1(jy:m-1,jy) = wn1(jy+1:m,jy+1)
      wn1(js:js+m-jy-1,js) = wn1(js+1:js+m-jy,js+1)
      wn1(m+1:m+m-1,jy) = wn1(m+2:m+m,jy+1)
    end do
  end if
  
!          put new rows in blocks (1,1), (2,1) and (2,2).
  pbegin = 1
  pend = nsub
  dbegin = nsub + 1
  dend = n
  iy = col
  is = m + col
  ipntr = head + col - 1
  if (ipntr > m) ipntr = ipntr - m
  jpntr = head
  do jy = 1, col
    js = m + jy
    temp1 = zero
    temp2 = zero
    temp3 = zero
!             compute element jy of row 'col' of Y'ZZ'Y
    do k = pbegin, pend
      k1 = ind(k)
      temp1 = temp1 + wy(k1,ipntr)*wy(k1,jpntr)
    end do
!             compute elements jy of row 'col' of L_a and S'AA'S
    do k = dbegin, dend
      k1 = ind(k)
      temp2 = temp2 + ws(k1,ipntr)*ws(k1,jpntr)
      temp3 = temp3 + ws(k1,ipntr)*wy(k1,jpntr)
    end do
    wn1(iy,jy) = temp1
    wn1(is,js) = temp2
    wn1(is,jy) = temp3
    jpntr = mod(jpntr,m) + 1
  end do
  
!          put new column in block (2,1).
  jy = col
  jpntr = head + col - 1
  if (jpntr > m) jpntr = jpntr - m
  ipntr = head
  do i = 1, col
    is = m + i
    temp3 = zero
!             compute element i of column 'col' of R_z
    do k = pbegin, pend
      k1 = ind(k)
      temp3 = temp3 + ws(k1,ipntr)*wy(k1,jpntr)
    end do
    ipntr = mod(ipntr,m) + 1
    wn1(is,jy) = temp3
  end do
  upcl = col - 1
else
  upcl = col
end if

!       modify the old parts in blocks (1,1) and (2,2) due to changes
!       in the set of free variables.
ipntr = head
do iy = 1, upcl
  is = m + iy
  jpntr = head
  do jy = 1, iy
    js = m + jy
    temp1 = zero
    temp2 = zero
    temp3 = zero
    temp4 = zero
    do k = 1, nenter
      k1 = indx2(k)
      temp1 = temp1 + wy(k1,ipntr)*wy(k1,jpntr)
      temp2 = temp2 + ws(k1,ipntr)*ws(k1,jpntr)
    end do
    do k = ileave, n
      k1 = indx2(k)
      temp3 = temp3 + wy(k1,ipntr)*wy(k1,jpntr)
      temp4 = temp4 + ws(k1,ipntr)*ws(k1,jpntr)
    end do
    wn1(iy,jy) = wn1(iy,jy) + temp1 - temp3
    wn1(is,js) = wn1(is,js) - temp2 + temp4
    jpntr = mod(jpntr,m) + 1
  end do
  ipntr = mod(ipntr,m) + 1
end do

!       modify the old parts in block (2,1).
ipntr = head
do is = m + 1, m + upcl
  jpntr = head
  do jy = 1, upcl
    temp1 = zero
    temp3 = zero
    do k = 1, nenter
      k1 = indx2(k)
      temp1 = temp1 + ws(k1,ipntr)*wy(k1,jpntr)
    end do
    do k = ileave, n
      k1 = indx2(k)
      temp3 = temp3 + ws(k1,ipntr)*wy(k1,jpntr)
    end do
    if (is <= jy + m) then
      wn1(is,jy) = wn1(is,jy) + temp1 - temp3
    else
      wn1(is,jy) = wn1(is,jy) - temp1 + temp3
    end if
    jpntr = mod(jpntr,m) + 1
  end do
  ipntr = mod(ipntr,m) + 1
end do

!     Form the upper triangle of WN = [D+Y' ZZ'Y/theta   -L_a'+R_z' ]
!                                     [-L_a +R_z        S'AA'S*theta]

do iy = 1, col
  is = col + iy
  is1 = m + iy
  do jy = 1, iy
    js = col + jy
    js1 = m + jy
    wn(jy,iy) = wn1(iy,jy)/theta
    wn(js,is) = wn1(is1,js1)*theta
  end do
  wn(1:iy-1,is) = -wn1(is1,1:iy-1)
  wn(iy:col,is) = wn1(is1,iy:col)
  wn(iy,iy) = wn(iy,iy) + sy(iy,iy)
end do

!     Form the upper triangle of
!          WN= [  LL'            L^-1(-L_a'+R_z')]
!              [(-L_a +R_z)L'^-1   S'AA'S*theta  ]

!        first Cholesky factor (1,1) block of wn to get LL'
!                          with L' stored in the upper triangle of wn.
call dpofa ( wn, col, info)
if (info /= 0) then
  info = -1
  return
end if
!        then form L^-1(-L_a'+R_z') in the (1,2) block.
col2 = 2*col
do js = col+1,col2
  call dtrsl(wn, col, wn(:,js), 11, info)
end do

!     Form S'AA'S*theta + (L^-1(-L_a'+R_z'))'L^-1(-L_a'+R_z') in the
!        upper triangle of (2,2) block of wn.


do is = col+1, col2
  do js = is, col2
    wn(is,js) = wn(is,js) + DOT_product( wn(1:col,is), wn(1:col,js) )
  end do
end do

!     Cholesky factorization of (2,2) block of wn.

call dpofa ( wn(col+1:,col+1:), col, info)
if (info /= 0) then
  info = -2
  return
end if

return

end subroutine formk

!======================= The end of formk ==============================

subroutine formt(wt, sy, ss, col, theta, info)

real (dp), intent(OUT)  :: wt(:, :)   ! wt(m, m)
real (dp), intent(IN)   :: sy(:, :)   ! sy(m, m)
real (dp), intent(IN)   :: ss(:, :)   ! ss(m, m)
integer, intent(IN)     :: col
real (dp), intent(IN)   :: theta
integer, intent(OUT)    :: info

!     ************

!     Subroutine formt

!       This subroutine forms the upper half of the pos. def. and symm.
!         T = theta*SS + L*D^(-1)*L', stores T in the upper triangle
!         of the array wt, and performs the Cholesky factorization of T
!         to produce J*J', with J' stored in the upper triangle of wt.

! N.B. Argument M has been removed.

!     Subprograms called:

!       Linpack ... dpofa.

!                           *  *  *

!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

integer   :: i, j, k, k1
real (dp) :: ddum

!     Form the upper half of  T = theta*SS + L*D^(-1)*L',
!        store T in the upper triangle of the array wt.

wt(1,1:col) = theta*ss(1,1:col)
do i = 2, col
  do j = i, col
    k1 = min(i,j) - 1
    ddum  = zero
    do k = 1, k1
      ddum  = ddum + sy(i,k)*sy(j,k)/sy(k,k)
    end do
    wt(i,j) = ddum + theta*ss(i,j)
  end do
end do

!     Cholesky factorize T to J*J' with J' stored in the upper triangle of wt.

call dpofa(wt, col, info)
if (info /= 0) then
  info = -3
end if

return

end subroutine formt

!======================= The end of formt ==============================

subroutine freev ( n, nfree, INDEX, nenter, ileave, indx2,  &
                 iwhere, wrk, updatd, cnstnd, iprint, iter )

integer, intent(IN)      :: n
integer, intent(IN OUT)  :: nfree
integer, intent(IN OUT)  :: index(:)
integer, intent(OUT)     :: nenter
integer, intent(OUT)     :: ileave
integer, intent(OUT)     :: indx2(:)
integer, intent(IN OUT)  :: iwhere(:)
logical, intent(OUT)     :: wrk
logical, intent(IN)      :: updatd
logical, intent(IN)      :: cnstnd
integer, intent(IN)      :: iprint
integer, intent(IN)      :: iter

!     ************

!     Subroutine freev

!     This subroutine counts the entering and leaving variables when iter > 0,
!       and finds the index set of free and active variables at the GCP.

!     cnstnd is a logical variable indicating whether bounds are present

!     index is an integer array of dimension n
!       for i=1,...,nfree, index(i) are the indices of free variables
!       for i=nfree+1,...,n, index(i) are the indices of bound variables
!       On entry after the first iteration, index gives
!         the free variables at the previous iteration.
!       On exit it gives the free variables based on the determination
!         in cauchy using the array iwhere.

!     indx2 is an integer array of dimension n
!       On entry indx2 is unspecified.
!       On exit with iter>0, indx2 indicates which variables
!          have changed status since the previous iteration.
!       For i= 1,...,nenter, indx2(i) have changed from bound to free.
!       For i= ileave+1,...,n, indx2(i) have changed from free to bound.

!                           *  *  *

!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

integer :: iact, i, k

nenter = 0
ileave = n + 1
if (iter > 0 .and. cnstnd) then
!                           count the entering and leaving variables.
  do i = 1, nfree
    k = index(i)
    if (iwhere(k) > 0) then
      ileave = ileave - 1
      indx2(ileave) = k
      if (iprint >= 100) write (6,*) 'Variable ', k, ' leaves the set of free variables'
    end if
  end do
  do i = 1 + nfree, n
    k = index(i)
    if ( iwhere(k) <= 0 ) then
      nenter = nenter + 1
      indx2(nenter) = k
      if (iprint >= 100) write (6,*) 'Variable ', k, ' enters the set of free variables'
    end if
  end do
  if (iprint >= 99) write (6,*) n+1-ileave, ' variables leave; ', nenter, ' variables enter'
end if
wrk = (ileave < n+1) .or. (nenter > 0) .or. updatd

!     Find the index set of free and active variables at the GCP.

nfree = 0
iact = n + 1
do i = 1, n
  if (iwhere(i) <= 0) then
    nfree = nfree + 1
    index(nfree) = i
  else
    iact = iact - 1
    index(iact) = i
 end if
end do
if (iprint >= 99) write (6,*) nfree, ' variables are free at GCP ', iter + 1

return

end subroutine freev

!======================= The end of freev ==============================

subroutine hpsolb(n, t, iorder, iheap)

integer, intent(IN)        :: n
real (dp), intent(IN OUT)  :: t(:)
integer, intent(IN OUT)    :: iorder(:)
integer, intent(IN)        :: iheap

!     ************

!     Subroutine hpsolb

!     This subroutine sorts out the least element of t, and puts the
!       remaining elements of t in a heap.

!     n is an integer variable.
!       On entry n is the dimension of the arrays t and iorder.
!       On exit n is unchanged.

!     t is a REAL (dp) array of dimension n.
!       On entry t stores the elements to be sorted,
!       On exit t(n) stores the least elements of t, and t(1) to t(n-1)
!         stores the remaining elements in the form of a heap.

!     iorder is an integer array of dimension n.
!       On entry iorder(i) is the index of t(i).
!       On exit iorder(i) is still the index of t(i), but iorder may be
!         permuted in accordance with t.

!     iheap is an integer variable specifying the task.
!       On entry iheap should be set as follows:
!         iheap .eq. 0 if t(1) to t(n) is not in the form of a heap,
!         iheap .ne. 0 if otherwise.
!       On exit iheap is unchanged.

!     References:
!       Algorithm 232 of CACM (J. W. J. Williams): HEAPSORT.

!                           *  *  *

!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

integer   :: i, j, k, indxin, indxou
real (dp) :: ddum, out

if (iheap == 0) then
  
!        Rearrange the elements t(1) to t(n) to form a heap.
  
  do k = 2, n
    ddum  = t(k)
    indxin = iorder(k)
    
!           Add ddum to the heap.
    i = k
    10 if (i > 1) then
      j = i/2
      if (ddum < t(j)) then
        t(i) = t(j)
        iorder(i) = iorder(j)
        i = j
        GO TO 10
      end if
    end if
    t(i) = ddum
    iorder(i) = indxin
  end do
end if

!     Assign to 'out' the value of t(1), the least member of the heap,
!        and rearrange the remaining members to form a heap as
!        elements 1 to n-1 of t.

if (n > 1) then
  i = 1
  out = t(1)
  indxou = iorder(1)
  ddum  = t(n)
  indxin  = iorder(n)
  
!        Restore the heap

  30 j = i+i
  if (j <= n-1) then
    if (t(j+1) < t(j)) j = j+1
    if (t(j) < ddum ) then
      t(i) = t(j)
      iorder(i) = iorder(j)
      i = j
      GO TO 30
    end if
  end if
  t(i) = ddum
  iorder(i) = indxin
  
!     Put the least member in t(n).
  
  t(n) = out
  iorder(n) = indxou
end if

return

end subroutine hpsolb

!====================== The end of hpsolb ==============================

subroutine lnsrlb(n, l, u, nbd, x, f, fold, gd, gdold, g, d, r, t,  &
                  z, stp, dnorm, dtd, xstep, stpmx, iter, ifun,  &
                  iback, nfgv, info, task, boxed, cnstnd, csave, isave, dsave)

integer, intent(IN)                :: n
real (dp), intent(IN)              :: l(:)
real (dp), intent(IN)              :: u(:)
integer, intent(IN)                :: nbd(:)
real (dp), intent(IN OUT)          :: x(:)
real (dp), intent(IN OUT)          :: f
real (dp), intent(OUT)             :: fold
real (dp), intent(OUT)             :: gd
real (dp), intent(OUT)             :: gdold
real (dp), intent(IN OUT)          :: g(:)
real (dp), intent(IN)              :: d(:)
real (dp), intent(IN OUT)          :: r(:)
real (dp), intent(IN OUT)          :: t(:)
real (dp), intent(IN OUT)          :: z(:)
real (dp), intent(OUT)             :: stp
real (dp), intent(OUT)             :: dnorm
real (dp), intent(OUT)             :: dtd
real (dp), intent(OUT)             :: xstep
real (dp), intent(OUT)             :: stpmx
integer, intent(IN OUT)            :: iter
integer, intent(OUT)               :: ifun
integer, intent(OUT)               :: iback
integer, intent(OUT)               :: nfgv
integer, intent(OUT)               :: info
character (LEN=60), intent(IN OUT) :: task
logical, intent(IN OUT)            :: boxed
logical, intent(IN OUT)            :: cnstnd
character (LEN=60), intent(OUT)    :: csave
integer, intent(IN OUT)            :: isave(2)
real (dp), intent(IN OUT)          :: dsave(13)

!     **********

!     Subroutine lnsrlb

!     This subroutine calls subroutine dcsrch from the Minpack2 library
!       to perform the line search.  Subroutine dscrch is safeguarded so
!       that all trial points lie within the feasible region.

!     Subprograms called:

!       Minpack2 Library ... dcsrch.

!       Linpack ... dtrsl, ddot.

!                           *  *  *

!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     **********

integer   :: i
real (dp) :: a1, a2
real (dp), parameter :: big = 1.0E+10_dp
real (dp), parameter :: ftol = 1.0D-3, gtol = 0.9_dp, xtol = 0.1_dp

if (task(1:5) == 'FG_LN') GO TO 556

dtd = sum( d(1:n)**2 )
dnorm = sqrt(dtd)

!     Determine the maximum step length.

stpmx = big
if (cnstnd) then
  if (iter == 0) then
    stpmx = one
  else
    do i = 1, n
      a1 = d(i)
      if (nbd(i) /= 0) then
        if (a1 < zero .and. nbd(i) <= 2) then
          a2 = l(i) - x(i)
          if (a2 >= zero) then
            stpmx = zero
          else if (a1*stpmx < a2) then
            stpmx = a2/a1
          end if
        else if (a1 > zero .and. nbd(i) >= 2) then
          a2 = u(i) - x(i)
          if (a2 <= zero) then
            stpmx = zero
          else if (a1*stpmx > a2) then
            stpmx = a2/a1
          end if
        end if
      end if
    end do
  end if
end if

if (iter == 0 .and. .not. boxed) then
  stp = min(one/dnorm, stpmx)
else
  stp = one
end if

t(1:n) = x(1:n)
r(1:n) = g(1:n)
fold = f
ifun = 0
iback = 0
csave = 'START'

556 gd = DOT_product( g(1:n), d(1:n) )
if (ifun == 0) then
  gdold=gd
  if (gd >= zero) then
!                               the directional derivative >=0.
!                               Line search is impossible.
    info = -4
    return
  end if
end if

call dcsrch(f, gd, stp, ftol, gtol, xtol, zero, stpmx, csave, isave, dsave)

xstep = stp*dnorm
if (csave(1:4) /= 'CONV' .and. csave(1:4) /= 'WARN') then
  task = 'FG_LNSRCH'
  ifun = ifun + 1
  nfgv = nfgv + 1
  iback = ifun - 1
  if ( abs(stp - one) < machine_eps ) then
    x(1:n) = z(1:n)
  else
    x(1:n) = stp*d(1:n) + t(1:n)
  end if
else
  task = 'NEW_X'
end if

return

end subroutine lnsrlb

!======================= The end of lnsrlb =============================

subroutine matupd(n, m, ws, wy, sy, ss, d, r, itail,  &
                  iupdat, col, head, theta, rr, dr, stp, dtd)

integer, intent(IN)     :: n
integer, intent(IN)     :: m
real (dp), intent(OUT)  :: ws(:, :)    ! ws(n, m)
real (dp), intent(OUT)  :: wy(:, :)    ! wy(n, m)
real (dp), intent(OUT)  :: sy(:, :)    ! sy(m, m)
real (dp), intent(OUT)  :: ss(:, :)    ! ss(m, m)
real (dp), intent(IN)   :: d(:)
real (dp), intent(IN)   :: r(:)
integer, intent(OUT)    :: itail
integer, intent(IN)     :: iupdat
integer, intent(OUT)    :: col
integer, intent(OUT)    :: head
real (dp), intent(OUT)  :: theta
real (dp), intent(IN)   :: rr
real (dp), intent(IN)   :: dr
real (dp), intent(IN)   :: stp
real (dp), intent(IN)   :: dtd

!     ************

!     Subroutine matupd

!       This subroutine updates matrices WS and WY, and forms the
!         middle matrix in B.

!     Subprograms called:

!       Linpack ... dcopy, ddot.

!                           *  *  *

!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

integer   :: j, pointr

!     Set pointers for matrices WS and WY.

if (iupdat <= m) then
  col = iupdat
  itail = mod(head+iupdat-2, m) + 1
else
  itail = mod(itail,m) + 1
  head = mod(head,m) + 1
end if

!     Update matrices WS and WY.

ws(1:n,itail) = d(1:n)
wy(1:n,itail) = r(1:n)

!     Set theta=yy/ys.

theta = rr/dr

!     Form the middle matrix in B.

!        update the upper triangle of SS, and the lower triangle of SY:

if (iupdat > m) then
!                              move old information
  do j = 1, col - 1
    ss(1:j,j) = ss(2:j+1,j+1)
    sy(j:col-1,j) = sy(j+1:col,j+1)
  end do
end if

!        add new information: the last row of SY and the last column of SS:

pointr = head
do j = 1, col - 1
  sy(col,j) = DOT_product( d(1:n), wy(1:n,pointr) )
  ss(j,col) = DOT_product( ws(1:n,pointr), d(1:n) )
  pointr = mod(pointr,m) + 1
end do
if ( abs(stp - one) < machine_eps ) then
  ss(col,col) = dtd
else
  ss(col,col) = stp*stp*dtd
end if
sy(col,col) = dr

return

end subroutine matupd

!======================= The end of matupd =============================

subroutine prn1lb(n, m, l, u, x, iprint, itfile, epsmch)

integer, intent(IN)    :: n
integer, intent(IN)    :: m
real (dp), intent(IN)  :: l(:)
real (dp), intent(IN)  :: u(:)
real (dp), intent(IN)  :: x(:)
integer, intent(IN)    :: iprint
integer, intent(IN)    :: itfile
real (dp), intent(IN)  :: epsmch

!     ************

!     Subroutine prn1lb

!     This subroutine prints the input data, initial point, upper and
!       lower bounds of each variable, machine precision, as well as
!       the headings of the output.

!                           *  *  *

!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

if (iprint >= 0) then
  write (6,7001) epsmch
  write (6,*) 'N = ', n, '    M = ', m
  if (iprint >= 1) then
    write (itfile,2001) epsmch
    write (itfile,*)' N = ', n, '    M = ', m
    write (itfile,9001)
    if (iprint > 100) then
      write (6,1004) ' L = ', l(1:n)
      write (6,1004) ' X0 = ', x(1:n)
      write (6,1004) ' U = ', u(1:n)
    end if
  end if
end if

1004 format (/ a6, 6(' ', g12.4)/ ('    ', 6(' ', g12.4)))
2001 format (' RUNNING THE L-BFGS-B CODE'// ' it    = iteration number'/   &
    ' nf    = number of function evaluations'/   &
    ' nint  = number of segments explored during the Cauchy search'/   &
    ' nact  = number of active bounds at the generalized Cauchy point' /   &
    ' sub   = manner in which the subspace minimization terminated:'/  &
    '         con = converged, bnd = a bound was reached'/   &
    ' itls  = number of iterations performed in the line search'/   &
    ' stepl = step length used'/   &
    ' tstep = norm of the displacement (total step)'/   &
    ' projg = norm of the projected gradient'/ ' f     = function value'//  &
    '           * * *' // ' Machine precision = ', g11.3)
7001 format (' RUNNING THE L-BFGS-B CODE'// '           * * *'//  &
    ' Machine precision =', g11.3)
9001 format (/ '   it   nf  nint  nact  sub  itls',  &
               '  stepl      tstep      projg        f')

return

end subroutine prn1lb

!======================= The end of prn1lb =============================

subroutine prn2lb(n, x, f, g, iprint, itfile, iter, nfgv, nact,  &
                  sbgnrm, nint, word, iword, iback, stp, xstep)

integer, intent(IN)               :: n
real (dp), intent(IN)             :: x(:)
real (dp), intent(IN)             :: f
real (dp), intent(IN)             :: g(:)
integer, intent(IN)               :: iprint
integer, intent(IN)               :: itfile
integer, intent(IN)               :: iter
integer, intent(IN)               :: nfgv
integer, intent(IN)               :: nact
real (dp), intent(IN)             :: sbgnrm
integer, intent(IN)               :: nint
character (LEN=3), intent(IN OUT) :: word
integer, intent(IN)               :: iword
integer, intent(IN)               :: iback
real (dp), intent(IN)             :: stp
real (dp), intent(IN)             :: xstep

!    ************

!    Subroutine prn2lb

!    This subroutine prints out new information after a successful line search.

!                          *  *  *

!    NEOS, November 1994. (Latest revision June 1996.)
!    Optimization Technology Center.
!    Argonne National Laboratory and Northwestern University.
!    Written by
!                       Ciyou Zhu
!    in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!    ************

integer :: imod

!           'word' records the status of subspace solutions.
if (iword == 0) then
!                            the subspace minimization converged.
  word = 'con'
else if (iword == 1) then
!                          the subspace minimization stopped at a bound.
  word = 'bnd'
else if (iword == 5) then
!                             the truncated Newton step has been used.
  word = 'TNT'
else
  word = '---'
end if

if (iprint >= 99) then
  write (6,*) 'LINE SEARCH ', iback, ' times; norm of step = ', xstep
  write (6,2001) iter, f, sbgnrm
  if (iprint > 100) then
    write (6,1004) ' X = ', x(1:n)
    write (6,1004) ' G = ', g(1:n)
  end if
else if (iprint > 0) then
  imod = mod(iter,iprint)
  if (imod == 0) write (6,2001) iter, f, sbgnrm
end if
if (iprint >= 1) write (itfile,3001)  &
    iter, nfgv, nint, nact, word, iback, stp, xstep, sbgnrm, f

1004 format (/ a5, 6(' ', g12.4)/ ('    ', 6(' ', g12.4)))
2001 format (/ ' At iterate', i5, '   f = ', g13.5, '    |proj g|= ', g13.5)
3001 format(2(' ', i4), 2(' ', i5), '  ', a3, ' ', i4, 2('  ', g9.1),  &
            2(' ', g11.3))

return

end subroutine prn2lb

!======================= The end of prn2lb =============================

subroutine prn3lb(n, x, f, task, iprint, info, itfile, iter, nfgv, nintol,  &
                  nskip, nact, sbgnrm, time, nint, word, iback, stp, xstep, &
                  k, cachyt, sbtime, lnscht)

integer, intent(IN)            :: n
real (dp), intent(IN)          :: x(:)
real (dp), intent(IN)          :: f
character (LEN=60), intent(IN) :: task
integer, intent(IN)            :: iprint
integer, intent(IN)            :: info
integer, intent(IN)            :: itfile
integer, intent(IN)            :: iter
integer, intent(IN)            :: nfgv
integer, intent(IN)            :: nintol
integer, intent(IN)            :: nskip
integer, intent(IN)            :: nact
real (dp), intent(IN)          :: sbgnrm
real (dp), intent(IN)          :: time
integer, intent(IN)            :: nint
character (LEN=3), intent(IN)  :: word
integer, intent(IN)            :: iback
real (dp), intent(IN)          :: stp
real (dp), intent(IN)          :: xstep
integer, intent(IN)            :: k
real (dp), intent(IN)          :: cachyt
real (dp), intent(IN)          :: sbtime
real (dp), intent(IN)          :: lnscht

!     ************

!     Subroutine prn3lb

!     This subroutine prints out information when either a built-in
!       convergence test is satisfied or when an error message is generated.

!                           *  *  *

!     NEOS, November 1994. (Latest revision April 1997.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

if (task(1:5) == 'ERROR') GO TO 999

if (iprint >= 0) then
  write (6,3003)
  write (6,3004)
  write (6,3005) n, iter, nfgv, nintol, nskip, nact, sbgnrm, f
  if (iprint >= 100) then
    write (6,1004) ' X = ', x(1:n)
  end if
  if (iprint >= 1) write (6,*) 'F = ', f
end if

999 if (iprint >= 0) then
  write (6,3009) task
  if (info /= 0) then
    if (info == -1) write (6,9011)
    if (info == -2) write (6,9012)
    if (info == -3) write (6,9013)
    if (info == -4) write (6,9014)
    if (info == -5) write (6,9015)
    if (info == -6) write (6,*) ' Input nbd(',k,') is invalid.'
    if (info == -7) write (6,*) ' l(', k, ') > u(', k, ').  No feasible solution.'
    if (info == -8) write (6,9018)
    if (info == -9) write (6,9019)
  end if
  if (iprint >= 1) write (6,3007) cachyt, sbtime, lnscht
  write (6,3008) time
  if (iprint >= 1) then
    if (info == -4 .or. info == -9) then
      write (itfile,3002) iter, nfgv, nint, nact, word, iback, stp, xstep
    end if
    write (itfile,3009) task
    if (info /= 0) then
      if (info == -1) write (itfile,9011)
      if (info == -2) write (itfile,9012)
      if (info == -3) write (itfile,9013)
      if (info == -4) write (itfile,9014)
      if (info == -5) write (itfile,9015)
      if (info == -8) write (itfile,9018)
      if (info == -9) write (itfile,9019)
    end if
    write (itfile,3008) time
  end if
end if

1004 format (/ a5,  6(' ', g12.4)/ ('    ', 6(' ', g12.4)))
3002 format(2(' ', i4), 2(' ', i5), '  ', a3, ' ', i4, 2('  ', g9.1), &
            '      -          -')
3003 format (/ '           * * *'//  &
    ' Tit   = total number of iterations'/   &
    ' Tnf   = total number of function evaluations'/   &
    ' Tnint = total number of segments explored during', ' Cauchy searches'/   &
    ' Skip  = number of BFGS updates skipped'/   &
    ' Nact  = number of active bounds at final generalized', ' Cauchy point'/   &
    ' Projg = norm of the final projected gradient'/   &
    ' F     = final function value'/ / '           * * *')
3004 format (/ '   N   Tit  Tnf  Tnint  ',  &
               'Skip  Nact     Projg         F')
3005 format (i5, 2(' ', i4), (' ', i6), ('  ', i4), (' ', i5), 2('  ', g11.3))
3007 format (/ ' Cauchy                time', e10.3,' seconds.',/  &
               ' Subspace minimization time', e10.3, ' seconds.',/  &
               ' Line search           time', e10.3, ' seconds.')
3008 format (/ ' Total User time', e10.3, ' seconds.',/)
3009 format (/ ' ', a)
9011 format (/  &
    ' Matrix in 1st Cholesky factorization in formk is not Pos. Def.')
9012 format (/  &
    ' Matrix in 2st Cholesky factorization in formk is not Pos. Def.')
9013 format (/  &
    ' Matrix in the Cholesky factorization in formt is not Pos. Def.')
9014 format (/ ' Derivative >= 0, backtracking line search impossible.'/   &
    '   Previous x, f and g restored.'/   &
    ' Possible causes: 1 error in function or gradient evaluation;'/   &
    '                  2 rounding errors dominate computation.')
9015 format (/ ' Warning:  more than 10 function and gradient'/   &
    '   evaluations in the last line search.  Termination'/   &
    '   may possibly be caused by a bad search direction.')
9018 format (/ ' The triangular system is singular.')
9019 format (/  &
    ' Line search cannot locate an adequate point after 20 function',/  &
    '  and gradient evaluations.  Previous x, f and g restored.'/   &
    ' Possible causes: 1 error in function or gradient evaluation;'/   &
    '                  2 rounding error dominate computation.')

return

end subroutine prn3lb

!======================= The end of prn3lb =============================

subroutine projgr(n, l, u, nbd, x, g, sbgnrm)

integer, intent(IN)     :: n
real (dp), intent(IN)   :: l(:)
real (dp), intent(IN)   :: u(:)
integer, intent(IN)     :: nbd(:)
real (dp), intent(IN)   :: x(:)
real (dp), intent(IN)   :: g(:)
real (dp), intent(OUT)  :: sbgnrm

!     ************

!     Subroutine projgr

!     This subroutine computes the infinity norm of the projected gradient.

!                           *  *  *

!     NEOS, November 1994. (Latest revision April 1997.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

integer   :: i
real (dp) :: gi

sbgnrm = zero
do i = 1, n
  gi = g(i)
  if (nbd(i) /= 0) then
    if (gi < zero) then
      if (nbd(i) >= 2) gi = max((x(i)-u(i)), gi)
    else
      if (nbd(i) <= 2) gi = min((x(i)-l(i)), gi)
    end if
  end if
  sbgnrm = max(sbgnrm, abs(gi))
end do

return

end subroutine projgr

!======================= The end of projgr =============================

subroutine subsm(n, m, nsub, ind, l, u, nbd, x, d, ws, wy, theta,  &
                 col, head, iword, wv, wn, iprint, info)

integer, intent(IN)        :: n
integer, intent(IN)        :: m
integer, intent(IN)        :: nsub
integer, intent(IN)        :: ind(:)
real (dp), intent(IN)      :: l(:)
real (dp), intent(IN)      :: u(:)
integer, intent(IN)        :: nbd(:)
real (dp), intent(IN OUT)  :: x(:)
real (dp), intent(IN OUT)  :: d(:)
real (dp), intent(IN)      :: ws(n, m)
real (dp), intent(IN)      :: wy(n, m)
real (dp), intent(IN)      :: theta
integer, intent(IN)        :: col
integer, intent(IN)        :: head
integer, intent(OUT)       :: iword
real (dp), intent(OUT)     :: wv(2*m)
real (dp), intent(IN)      :: wn(2*m, 2*m)
integer, intent(IN)        :: iprint
integer, intent(OUT)       :: info

!     ************

!     Subroutine subsm

!     Given xcp, l, u, r, an index set that specifies the active set at xcp,
!       and an l-BFGS matrix B (in terms of WY, WS, SY, WT, head, col,
!       and theta),
!       this subroutine computes an approximate solution of the subspace
!       problem

!       (P)   min Q(x) = r'(x-xcp) + 1/2 (x-xcp)' B (x-xcp)

!             subject to l <= x <= u
!                       x_i = xcp_i for all i in A(xcp)

!       along the subspace unconstrained Newton direction

!          d = -(Z'BZ)^(-1) r.

!       The formula for the Newton direction, given the L-BFGS matrix
!       and the Sherman-Morrison formula, is

!          d = (1/theta)r + (1/theta*2) Z'WK^(-1)W'Z r.

!       where
!                 K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                     [L_a -R_z           theta*S'AA'S ]

!     Note that this procedure for computing d differs from that described
!     in [1]. One can show that the matrix K is equal to the matrix M^[-1]N in
!     that paper.

!     n is an integer variable.
!       On entry n is the dimension of the problem.
!       On exit n is unchanged.

!     m is an integer variable.
!       On entry m is the maximum number of variable metric corrections
!         used to define the limited memory matrix.
!       On exit m is unchanged.

!     nsub is an integer variable.
!       On entry nsub is the number of free variables.
!       On exit nsub is unchanged.

!     ind is an integer array of dimension nsub.
!       On entry ind specifies the coordinate indices of free variables.
!       On exit ind is unchanged.

!     l is a REAL (dp) array of dimension n.
!       On entry l is the lower bound of x.
!       On exit l is unchanged.

!     u is a REAL (dp) array of dimension n.
!       On entry u is the upper bound of x.
!       On exit u is unchanged.

!     nbd is a integer array of dimension n.
!       On entry nbd represents the type of bounds imposed on the
!         variables, and must be specified as follows:
!         nbd(i)=0 if x(i) is unbounded,
!                1 if x(i) has only a lower bound,
!                2 if x(i) has both lower and upper bounds, and
!                3 if x(i) has only an upper bound.
!       On exit nbd is unchanged.

!     x is a REAL (dp) array of dimension n.
!       On entry x specifies the Cauchy point xcp.
!       On exit x(i) is the minimizer of Q over the subspace of free variables.

!     d is a REAL (dp) array of dimension n.
!       On entry d is the reduced gradient of Q at xcp.
!       On exit d is the Newton direction of Q.

!     ws and wy are REAL (dp) arrays;
!     theta is a REAL (dp) variable;
!     col is an integer variable;
!     head is an integer variable.
!       On entry they store the information defining the
!                                          limited memory BFGS matrix:
!         ws(n,m) stores S, a set of s-vectors;
!         wy(n,m) stores Y, a set of y-vectors;
!         theta is the scaling factor specifying B_0 = theta I;
!         col is the number of variable metric corrections stored;
!         head is the location of the 1st s- (or y-) vector in S (or Y).
!       On exit they are unchanged.

!     iword is an integer variable.
!       On entry iword is unspecified.
!       On exit iword specifies the status of the subspace solution.
!         iword = 0 if the solution is in the box,
!                 1 if some bound is encountered.

!     wv is a REAL (dp) working array of dimension 2m.

!     wn is a REAL (dp) array of dimension 2m x 2m.
!       On entry the upper triangle of wn stores the LEL^T factorization
!         of the indefinite matrix

!              K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]
!                  [L_a -R_z           theta*S'AA'S ]
!                                                    where E = [-I  0]
!                                                              [ 0  I]
!       On exit wn is unchanged.

!     iprint is an INTEGER variable that must be set by the user.
!       It controls the frequency and type of output generated:
!        iprint<0    no output is generated;
!        iprint=0    print only one line at the last iteration;
!        0<iprint<99 print also f and |proj g| every iprint iterations;
!        iprint=99   print details of every iteration except n-vectors;
!        iprint=100  print also the changes of active set and final x;
!        iprint>100  print details of every iteration including x and g;
!       When iprint > 0, the file iterate.dat will be created to
!                        summarize the iteration.

!     info is an integer variable.
!       On entry info is unspecified.
!       On exit info = 0       for normal return,
!                    = nonzero for abnormal return
!                                  when the matrix K is ill-conditioned.

!     Subprograms called:

!       Linpack dtrsl.

!     References:

!       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
!       memory algorithm for bound constrained optimization'',
!       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.

!                           *  *  *

!     NEOS, November 1994. (Latest revision June 1996.)
!     Optimization Technology Center.
!     Argonne National Laboratory and Northwestern University.
!     Written by
!                        Ciyou Zhu
!     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.

!     ************

integer   :: pointr, col2, ibd, jy, js, i, j, k
real (dp) :: alpha, dk, temp1, temp2

if (nsub <= 0) return
if (iprint >= 99) write (6,1001)

!     Compute wv = W'Zd.

pointr = head
do i = 1, col
  temp1 = zero
  temp2 = zero
  do j = 1, nsub
    k = ind(j)
    temp1 = temp1 + wy(k,pointr)*d(j)
    temp2 = temp2 + ws(k,pointr)*d(j)
  end do
  wv(i) = temp1
  wv(col + i) = theta*temp2
  pointr = mod(pointr,m) + 1
end do

!     Compute wv:=K^(-1)wv.

col2 = 2*col
call dtrsl(wn, col2, wv, 11, info)
if (info /= 0) return
do i = 1, col
  wv(i) = -wv(i)
end do
call dtrsl(wn, col2, wv, 01, info)
if (info /= 0) return

!     Compute d = (1/theta)d + (1/theta**2)Z'W wv.

pointr = head
do jy = 1, col
  js = col + jy
  do i = 1, nsub
    k = ind(i)
    d(i) = d(i) + wy(k,pointr)*wv(jy)/theta + ws(k,pointr)*wv(js)
  end do
  pointr = mod(pointr,m) + 1
end do
do i = 1, nsub
  d(i) = d(i)/theta
end do

!     Backtrack to the feasible region.

alpha = one
temp1 = alpha
do i = 1, nsub
  k = ind(i)
  dk = d(i)
  if (nbd(k) /= 0) then
    if (dk < zero .and. nbd(k) <= 2) then
      temp2 = l(k) - x(k)
      if (temp2 >= zero) then
        temp1 = zero
      else if (dk*alpha < temp2) then
        temp1 = temp2/dk
      end if
    else if (dk > zero .and. nbd(k) >= 2) then
      temp2 = u(k) - x(k)
      if (temp2 <= zero) then
        temp1 = zero
      else if (dk*alpha > temp2) then
        temp1 = temp2/dk
      end if
    end if
    if (temp1 < alpha) then
      alpha = temp1
      ibd = i
    end if
  end if
end do

if (alpha < one) then
  dk = d(ibd)
  k = ind(ibd)
  if (dk > zero) then
    x(k) = u(k)
    d(ibd) = zero
  else if (dk < zero) then
    x(k) = l(k)
    d(ibd) = zero
  end if
end if
do i = 1, nsub
  k = ind(i)
  x(k) = x(k) + alpha*d(i)
end do

if (iprint >= 99) then
  if (alpha < one) then
    write (6,1002) alpha
  else
    write (6,*) 'SM solution inside the box'
  end if
  if (iprint > 100) write (6,1003) x(1:n)
end if

if (alpha < one) then
  iword = 1
else
  iword = 0
end if
if (iprint >= 99) write (6,1004)

1001 format (/ ' ----------------SUBSM entered-----------------',/)
1002 format ( ' ALPHA = ',f7.5,' backtrack to the BOX')
1003 format (' Subspace solution X =  '/ ('    ', 6(' ', g12.4)))
1004 format (/' ----------------exit SUBSM --------------------',/)

return

end subroutine subsm

!====================== The end of subsm ===============================

subroutine dcsrch(f, g, stp, ftol, gtol, xtol, stpmin, stpmax, task,  &
                  isave, dsave)

real (dp), intent(IN OUT)         :: f
real (dp), intent(IN OUT)         :: g
real (dp), intent(IN OUT)         :: stp
real (dp), intent(IN)             :: ftol
real (dp), intent(IN)             :: gtol
real (dp), intent(IN)             :: xtol
real (dp), intent(IN)             :: stpmin
real (dp), intent(IN)             :: stpmax
character (LEN=*), intent(IN OUT) :: task
integer, intent(IN OUT)           :: isave(2)
real (dp), intent(IN OUT)         :: dsave(13)

!     **********

!     Subroutine dcsrch

!     This subroutine finds a step that satisfies a sufficient
!     decrease condition and a curvature condition.

!     Each call of the subroutine updates an interval with
!     endpoints stx and sty. The interval is initially chosen
!     so that it contains a minimizer of the modified function

!           psi(stp) = f(stp) - f(0) - ftol*stp*f'(0).

!     If psi(stp) <= 0 and f'(stp) >= 0 for some step, then the
!     interval is chosen so that it contains a minimizer of f.

!     The algorithm is designed to find a step that satisfies
!     the sufficient decrease condition

!           f(stp) <= f(0) + ftol*stp*f'(0),

!     and the curvature condition

!           abs(f'(stp)) <= gtol*abs(f'(0)).

!     If ftol is less than gtol and if, for example, the function is bounded
!     below, then there is always a step which satisfies both conditions.

!     If no step can be found that satisfies both conditions, then
!     the algorithm stops with a warning. In this case stp only
!     satisfies the sufficient decrease condition.

!     A typical invocation of dcsrch has the following outline:

!     task = 'START'
!  10 continue
!        call dcsrch( ... )
!        if (task .eq. 'FG') then
!           Evaluate the function and the gradient at stp
!           goto 10
!           end if

!     NOTE: The user must not alter work arrays between calls.

!     The subroutine statement is

!        subroutine dcsrch(f,g,stp,ftol,gtol,xtol,stpmin,stpmax,
!                          task,isave,dsave)
!     where

!       f is a REAL (dp) variable.
!         On initial entry f is the value of the function at 0.
!            On subsequent entries f is the value of the function at stp.
!         On exit f is the value of the function at stp.

!       g is a REAL (dp) variable.
!         On initial entry g is the derivative of the function at 0.
!            On subsequent entries g is the derivative of the function at stp.
!         On exit g is the derivative of the function at stp.

!       stp is a REAL (dp) variable.
!         On entry stp is the current estimate of a satisfactory step.
!            On initial entry, a positive initial estimate must be provided.
!         On exit stp is the current estimate of a satisfactory step
!            if task = 'FG'. If task = 'CONV' then stp satisfies
!            the sufficient decrease and curvature condition.

!       ftol is a REAL (dp) variable.
!         On entry ftol specifies a nonnegative tolerance for the
!            sufficient decrease condition.
!         On exit ftol is unchanged.

!       gtol is a REAL (dp) variable.
!         On entry gtol specifies a nonnegative tolerance for the
!            curvature condition.
!         On exit gtol is unchanged.

!       xtol is a REAL (dp) variable.
!         On entry xtol specifies a nonnegative relative tolerance for an
!            acceptable step. The subroutine exits with a warning if the
!            relative difference between sty and stx is less than xtol.
!         On exit xtol is unchanged.

!       stpmin is a REAL (dp) variable.
!         On entry stpmin is a nonnegative lower bound for the step.
!         On exit stpmin is unchanged.

!       stpmax is a REAL (dp) variable.
!         On entry stpmax is a nonnegative upper bound for the step.
!         On exit stpmax is unchanged.

!       task is a character variable of length at least 60.
!         On initial entry task must be set to 'START'.
!         On exit task indicates the required action:

!            If task(1:2) = 'FG' then evaluate the function and
!            derivative at stp and call dcsrch again.

!            If task(1:4) = 'CONV' then the search is successful.

!            If task(1:4) = 'WARN' then the subroutine is not able
!            to satisfy the convergence conditions. The exit value of
!            stp contains the best point found during the search.

!            If task(1:5) = 'ERROR' then there is an error in the
!            input arguments.

!         On exit with convergence, a warning or an error, the
!            variable task contains additional information.

!       isave is an integer work array of dimension 2.

!       dsave is a REAL (dp) work array of dimension 13.

!     Subprograms called

!       MINPACK-2 ... dcstep

!     MINPACK-1 Project. June 1983.
!     Argonne National Laboratory.
!     Jorge J. More' and David J. Thuente.

!     MINPACK-2 Project. October 1993.
!     Argonne National Laboratory and University of Minnesota.
!     Brett M. Averick, Richard G. Carter, and Jorge J. More'.

!     **********
real (dp), parameter :: p5=0.5_dp, p66=0.66_dp
real (dp), parameter :: xtrapl=1.1_dp, xtrapu=4.0_dp

logical   :: brackt
integer   :: stage
real (dp) :: finit, ftest, fm, fx, fxm, fy, fym, ginit, gtest,  &
             gm, gx, gxm, gy, gym, stx, sty, stmin, stmax, width, width1

!     Initialization block.

if (task(1:5) == 'START') then
  
!        Check the input arguments for errors.
  
  if (stp < stpmin) task = 'ERROR: STP .LT. STPMIN'
  if (stp > stpmax) task = 'ERROR: STP .GT. STPMAX'
  if (g >= zero) task = 'ERROR: INITIAL G .GE. ZERO'
  if (ftol < zero) task = 'ERROR: FTOL .LT. ZERO'
  if (gtol < zero) task = 'ERROR: GTOL .LT. ZERO'
  if (xtol < zero) task = 'ERROR: XTOL .LT. ZERO'
  if (stpmin < zero) task = 'ERROR: STPMIN .LT. ZERO'
  if (stpmax < stpmin) task = 'ERROR: STPMAX .LT. STPMIN'
  
!        Exit if there are errors on input.
  
  if (task(1:5) == 'ERROR') return
  
!        Initialize local variables.
  
  brackt = .false.
  stage = 1
  finit = f
  ginit = g
  gtest = ftol*ginit
  width = stpmax - stpmin
  width1 = width/p5
  
!        The variables stx, fx, gx contain the values of the step,
!        function, and derivative at the best step.
!        The variables sty, fy, gy contain the value of the step,
!        function, and derivative at sty.
!        The variables stp, f, g contain the values of the step,
!        function, and derivative at stp.
  
  stx = zero
  fx = finit
  gx = ginit
  sty = zero
  fy = finit
  gy = ginit
  stmin = zero
  stmax = stp + xtrapu*stp
  task = 'FG'
  
  GO TO 1000
  
else
  
!        Restore local variables.
  
  if (isave(1) == 1) then
    brackt = .true.
  else
    brackt = .false.
  end if
  stage = isave(2)
  ginit = dsave(1)
  gtest = dsave(2)
  gx = dsave(3)
  gy = dsave(4)
  finit = dsave(5)
  fx = dsave(6)
  fy = dsave(7)
  stx = dsave(8)
  sty = dsave(9)
  stmin = dsave(10)
  stmax = dsave(11)
  width = dsave(12)
  width1 = dsave(13)
  
end if

!     If psi(stp) <= 0 and f'(stp) >= 0 for some step, then the
!     algorithm enters the second stage.

ftest = finit + stp*gtest
if (stage == 1 .and. f <= ftest .and. g >= zero) stage = 2

!     Test for warnings.

if ( brackt .and. ( stp <= stmin .or. stp >= stmax) )  &
    task = 'WARNING: ROUNDING ERRORS PREVENT PROGRESS'
if ( brackt .and. stmax - stmin <= xtol*stmax )  &
    task = 'WARNING: XTOL TEST SATISFIED'
if ( abs( stp - stpmax ) < machine_eps .and. f <= ftest .and. g <= gtest )  &
    task = 'WARNING: STP = STPMAX'
if ( abs( stp - stpmin ) < machine_eps .and. (f > ftest .or. g >= gtest) )  &
    task = 'WARNING: STP = STPMIN'

!     Test for convergence.

if ( f <= ftest .and. abs(g) <= gtol*(-ginit) ) task = 'CONVERGENCE'

!     Test for termination.

if ( task(1:4) == 'WARN' .or. task(1:4) == 'CONV' ) GO TO 1000

!     A modified function is used to predict the step during the first stage
!     if a lower function value has been obtained but the decrease is not
!     sufficient.

if ( stage == 1 .and. f <= fx .and. f > ftest ) then
  
!        Define the modified function and derivative values.
  
  fm = f - stp*gtest
  fxm = fx - stx*gtest
  fym = fy - sty*gtest
  gm = g - gtest
  gxm = gx - gtest
  gym = gy - gtest
  
!        Call dcstep to update stx, sty, and to compute the new step.
  
  call dcstep(stx, fxm, gxm, sty, fym, gym, stp, fm, gm, brackt, stmin, stmax)
  
!        Reset the function and derivative values for f.
  
  fx = fxm + stx*gtest
  fy = fym + sty*gtest
  gx = gxm + gtest
  gy = gym + gtest
  
else
  
!       Call dcstep to update stx, sty, and to compute the new step.
  
  call dcstep(stx, fx, gx, sty, fy, gy, stp, f, g, brackt, stmin, stmax)
  
end if

!     Decide if a bisection step is needed.

if (brackt) then
  if (abs(sty-stx) >= p66*width1) stp = stx + p5*(sty - stx)
  width1 = width
  width = abs(sty-stx)
end if

!     Set the minimum and maximum steps allowed for stp.

if (brackt) then
  stmin = min(stx, sty)
  stmax = max(stx, sty)
else
  stmin = stp + xtrapl*(stp - stx)
  stmax = stp + xtrapu*(stp - stx)
end if

!     Force the step to be within the bounds stpmax and stpmin.

stp = max(stp, stpmin)
stp = min(stp, stpmax)

!     If further progress is not possible, let stp be the best
!     point obtained during the search.

if (brackt .and. (stp <= stmin .or. stp >= stmax)  &
    .or. (brackt .and. stmax-stmin <= xtol*stmax)) stp = stx

!     Obtain another function and derivative.

task = 'FG'

!     Save local variables.

1000 if (brackt) then
  isave(1) = 1
else
  isave(1) = 0
end if
isave(2) = stage
dsave(1) =  ginit
dsave(2) =  gtest
dsave(3) =  gx
dsave(4) =  gy
dsave(5) =  finit
dsave(6) =  fx
dsave(7) =  fy
dsave(8) =  stx
dsave(9) =  sty
dsave(10) = stmin
dsave(11) = stmax
dsave(12) = width
dsave(13) = width1

return
end subroutine dcsrch

!====================== The end of dcsrch ==============================

subroutine dcstep(stx, fx, dx, sty, fy, dy, stp, fp, ddp, brackt, stpmin,  &
                  stpmax)

real (dp), intent(IN OUT)  :: stx
real (dp), intent(IN OUT)  :: fx
real (dp), intent(IN OUT)  :: dx
real (dp), intent(OUT)     :: sty
real (dp), intent(OUT)     :: fy
real (dp), intent(IN OUT)  :: dy
real (dp), intent(IN OUT)  :: stp
real (dp), intent(IN)      :: fp
real (dp), intent(IN)      :: ddp
logical, intent(OUT)       :: brackt
real (dp), intent(IN)      :: stpmin
real (dp), intent(IN)      :: stpmax

!     **********

!     Subroutine dcstep

!     This subroutine computes a safeguarded step for a search
!     procedure and updates an interval that contains a step that
!     satisfies a sufficient decrease and a curvature condition.

!     The parameter stx contains the step with the least function value.
!     If brackt is set to .true. then a minimizer has
!     been bracketed in an interval with endpoints stx and sty.
!     The parameter stp contains the current step.
!     The subroutine assumes that if brackt is set to .true. then

!           min(stx,sty) < stp < max(stx,sty),

!     and that the derivative at stx is negative in the direction of the step.

!     The subroutine statement is

!       subroutine dcstep(stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt, stpmin,stpmax)

!     where

!       stx is a REAL (dp) variable.
!         On entry stx is the best step obtained so far and is an
!            endpoint of the interval that contains the minimizer.
!         On exit stx is the updated best step.

!       fx is a REAL (dp) variable.
!         On entry fx is the function at stx.
!         On exit fx is the function at stx.

!       dx is a REAL (dp) variable.
!         On entry dx is the derivative of the function at
!            stx. The derivative must be negative in the direction of
!            the step, that is, dx and stp - stx must have opposite
!            signs.
!         On exit dx is the derivative of the function at stx.

!       sty is a REAL (dp) variable.
!         On entry sty is the second endpoint of the interval that
!            contains the minimizer.
!         On exit sty is the updated endpoint of the interval that
!            contains the minimizer.

!       fy is a REAL (dp) variable.
!         On entry fy is the function at sty.
!         On exit fy is the function at sty.

!       dy is a REAL (dp) variable.
!         On entry dy is the derivative of the function at sty.
!         On exit dy is the derivative of the function at the exit sty.

!       stp is a REAL (dp) variable.
!         On entry stp is the current step. If brackt is set to .true.
!            then on input stp must be between stx and sty.
!         On exit stp is a new trial step.

!       fp is a REAL (dp) variable.
!         On entry fp is the function at stp
!         On exit fp is unchanged.

!       ddp is a REAL (dp) variable.
!         On entry dp is the the derivative of the function at stp.
!         On exit dp is unchanged.

!       brackt is an logical variable.
!         On entry brackt specifies if a minimizer has been bracketed.
!            Initially brackt must be set to .false.
!         On exit brackt specifies if a minimizer has been bracketed.
!            When a minimizer is bracketed brackt is set to .true.

!       stpmin is a REAL (dp) variable.
!         On entry stpmin is a lower bound for the step.
!         On exit stpmin is unchanged.

!       stpmax is a REAL (dp) variable.
!         On entry stpmax is an upper bound for the step.
!         On exit stpmax is unchanged.

!     MINPACK-1 Project. June 1983
!     Argonne National Laboratory.
!     Jorge J. More' and David J. Thuente.

!     MINPACK-2 Project. October 1993.
!     Argonne National Laboratory and University of Minnesota.
!     Brett M. Averick and Jorge J. More'.

!     **********
real (dp), parameter :: p66 = 0.66_dp, two = 2.0_dp, three = 3.0_dp

real (dp) :: gamma, p, q, r, s, sgnd, stpc, stpf, stpq, theta

sgnd = ddp*(dx/abs(dx))

!     First case: A higher function value. The minimum is bracketed.
!     If the cubic step is closer to stx than the quadratic step, the
!     cubic step is taken, otherwise the average of the cubic and
!     quadratic steps is taken.

if (fp > fx) then
  theta = three*(fx - fp)/(stp - stx) + dx + ddp
  s = max(abs(theta),abs(dx),abs(ddp))
  gamma = s*sqrt((theta/s)**2 - (dx/s)*(ddp/s))
  if (stp < stx) gamma = -gamma
  p = (gamma - dx) + theta
  q = ((gamma - dx) + gamma) + ddp
  r = p/q
  stpc = stx + r*(stp - stx)
  stpq = stx + ((dx/((fx - fp)/(stp - stx) + dx))/two)* (stp - stx)
  if (abs(stpc-stx) < abs(stpq-stx)) then
    stpf = stpc
  else
    stpf = stpc + (stpq - stpc)/two
  end if
  brackt = .true.
  
!     Second case: A lower function value and derivatives of opposite sign.
!     The minimum is bracketed. If the cubic step is farther from stp than the
!     secant step, the cubic step is taken, otherwise the secant step is taken.
  
else if (sgnd < zero) then
  theta = three*(fx - fp)/(stp - stx) + dx + ddp
  s = max(abs(theta),abs(dx),abs(ddp))
  gamma = s*sqrt((theta/s)**2 - (dx/s)*(ddp/s))
  if (stp > stx) gamma = -gamma
  p = (gamma - ddp) + theta
  q = ((gamma - ddp) + gamma) + dx
  r = p/q
  stpc = stp + r*(stx - stp)
  stpq = stp + (ddp/(ddp - dx))*(stx - stp)
  if (abs(stpc-stp) > abs(stpq-stp)) then
    stpf = stpc
  else
    stpf = stpq
  end if
  brackt = .true.
  
!     Third case: A lower function value, derivatives of the same sign,
!     and the magnitude of the derivative decreases.
  
else if (abs(ddp) < abs(dx)) then
  
!        The cubic step is computed only if the cubic tends to infinity in the
!        direction of the step or if the minimum of the cubic is beyond stp.
!        Otherwise the cubic step is defined to be the secant step.
  
  theta = three*(fx - fp)/(stp - stx) + dx + ddp
  s = max(abs(theta), abs(dx), abs(ddp))
  
!        The case gamma = 0 only arises if the cubic does not tend
!        to infinity in the direction of the step.
  
  gamma = s*sqrt(max(zero, (theta/s)**2-(dx/s)*(ddp/s)))
  if (stp > stx) gamma = -gamma
  p = (gamma - ddp) + theta
  q = (gamma + (dx - ddp)) + gamma
  r = p/q
  if (r < zero .and. abs( gamma ) > machine_eps ) then
    stpc = stp + r*(stx - stp)
  else if (stp > stx) then
    stpc = stpmax
  else
    stpc = stpmin
  end if
  stpq = stp + (ddp/(ddp - dx))*(stx - stp)
  
  if (brackt) then
    
!           A minimizer has been bracketed. If the cubic step is closer to stp
!           than the secant step, the cubic step is taken, otherwise the secant
!           step is taken.
    
    if (abs(stpc-stp) < abs(stpq-stp)) then
      stpf = stpc
    else
      stpf = stpq
    end if
    if (stp > stx) then
      stpf = min(stp+p66*(sty-stp), stpf)
    else
      stpf = max(stp+p66*(sty-stp), stpf)
    end if
  else
    
!           A minimizer has not been bracketed. If the cubic step is farther
!           from stp than the secant step, the cubic step is taken,
!           otherwise the secant step is taken.
    
    if (abs(stpc-stp) > abs(stpq-stp)) then
      stpf = stpc
    else
      stpf = stpq
    end if
    stpf = min(stpmax,stpf)
    stpf = max(stpmin,stpf)
  end if
  
!     Fourth case: A lower function value, derivatives of the same sign, and
!     the magnitude of the derivative does not decrease.  If the minimum is
!     not bracketed, the step is either stpmin or stpmax, otherwise the
!     cubic step is taken.
  
else
  if (brackt) then
    theta = three*(fp - fy)/(sty - stp) + dy + ddp
    s = max(abs(theta),abs(dy),abs(ddp))
    gamma = s*sqrt((theta/s)**2 - (dy/s)*(ddp/s))
    if (stp > sty) gamma = -gamma
    p = (gamma - ddp) + theta
    q = ((gamma - ddp) + gamma) + dy
    r = p/q
    stpc = stp + r*(sty - stp)
    stpf = stpc
  else if (stp > stx) then
    stpf = stpmax
  else
    stpf = stpmin
  end if
end if

!     Update the interval which contains a minimizer.

if (fp > fx) then
  sty = stp
  fy = fp
  dy = ddp
else
  if (sgnd < zero) then
    sty = stx
    fy = fx
    dy = dx
  end if
  stx = stp
  fx = fp
  dx = ddp
end if

!     Compute the new step.

stp = stpf

return
end subroutine dcstep

!====================== The end of dcstep ==============================

subroutine dpofa(a, n, info)

real (dp), intent(IN OUT)  :: a(:,:)
integer, intent(IN)        :: n
integer, intent(OUT)       :: info

!     dpofa factors a REAL (dp) symmetric positive definite matrix.

!     dpofa is usually called by dpoco, but it can be called
!     directly with a saving in time if  rcond  is not needed.
!     (time for dpoco) = (1 + 18/n)*(time for dpofa) .

!     on entry

!        a       REAL (dp)(lda, n)
!                the symmetric matrix to be factored.  Only the
!                diagonal and upper triangle are used.

!        lda     integer
!                the leading dimension of the array  a .

!        n       integer
!                the order of the matrix  a .

!     on return

!        a       an upper triangular matrix  r  so that  a = trans(r)*r
!                where  trans(r)  is the transpose.
!                the strict lower triangle is unaltered.
!                if  info .ne. 0 , the factorization is not complete.

!        info    integer
!                = 0  for normal return.
!                = k  signals an error condition.  The leading minor
!                     of order  k  is not positive definite.

! N.B. Argument LDA has been removed.

!     linpack.  this version dated 08/14/78 .
!     cleve moler, university of new mexico, argonne national lab.

!     subroutines and functions

!     blas ddot
!     fortran sqrt

!     internal variables

real (dp) :: t
real (dp) :: s
integer   :: j, jm1, k

!     begin block with ...exits to 40

do j = 1, n
  info = j
  s = 0.0_dp
  jm1 = j - 1
  do k = 1, jm1
    t = a(k,j) - DOT_product( a(1:k-1,k), a(1:k-1,j) )
    t = t/a(k,k)
    a(k,j) = t
    s = s + t*t
  end do

  s = a(j,j) - s
!     ......exit
  if (s <= 0.0_dp) GO TO 40
  a(j,j) = sqrt(s)
end do
info = 0

40 return
end subroutine dpofa


subroutine dtrsl(t, n, b, job, info)

real (dp), intent(IN)     :: t(:,:)
integer, intent(IN)       :: n
real (dp), intent(IN OUT) :: b(:)
integer, intent(IN)       :: job
integer, intent(OUT)      :: info

!     dtrsl solves systems of the form

!                   t * x = b
!     or
!                   trans(t) * x = b

!     where t is a triangular matrix of order n.  Here trans(t)
!     denotes the transpose of the matrix t.

!     on entry

!         t         REAL (dp)(ldt,n)
!                   t contains the matrix of the system.  The zero elements
!                   of the matrix are not referenced, and the corresponding
!                   elements of the array can be used to store other
!                   information.

!         ldt       integer
!                   ldt is the leading dimension of the array t.

!         n         integer
!                   n is the order of the system.

!         b         REAL (dp)(n).
!                   b contains the right hand side of the system.

!         job       integer
!                   job specifies what kind of system is to be solved.
!                   if job is

!                        00   solve t*x=b, t lower triangular,
!                        01   solve t*x=b, t upper triangular,
!                        10   solve trans(t)*x=b, t lower triangular,
!                        11   solve trans(t)*x=b, t upper triangular.

!     on return

!         b         b contains the solution, if info .eq. 0.
!                   otherwise b is unaltered.

!         info      integer
!                   info contains zero if the system is nonsingular.
!                   otherwise info contains the index of
!                   the first zero diagonal element of t.

! N.B. Argument LDT has been removed.

!     linpack. this version dated 08/14/78 .
!     g. w. stewart, university of maryland, argonne national lab.

!     subroutines and functions

!     blas daxpy,ddot
!     fortran mod

!     internal variables

real (dp) :: temp
integer   :: case, j, jj

!     begin block permitting ...exits to 150

!        check for zero diagonal elements.

do info = 1, n
!     ......exit
  if ( abs( t(info,info) ) < machine_eps ) GO TO 140
end do
info = 0

!        determine the task and go to it.

case = 1
if (mod(job,10) /= 0) case = 2
if (mod(job,100)/10 /= 0) case = case + 2
select case ( case )
  case (    1)
    GO TO 20
  case (    2)
    GO TO 50
  case (    3)
    GO TO 80
  case (    4)
    GO TO 110
end select

!        solve t*x=b for t lower triangular

20 b(1) = b(1)/t(1,1)
do j = 2, n
  temp = -b(j-1)
  b(j:n) = b(j:n) + temp * t(j:n,j-1)
  b(j) = b(j)/t(j,j)
end do
GO TO 140

!        solve t*x=b for t upper triangular.

50 b(n) = b(n)/t(n,n)
do jj = 2, n
  j = n - jj + 1
  temp = -b(j+1)
  b(1:j) = b(1:j) + temp * t(1:j,j+1)
  b(j) = b(j)/t(j,j)
end do
GO TO 140

!        solve trans(t)*x=b for t lower triangular.

80 b(n) = b(n)/t(n,n)
do jj = 2, n
  j = n - jj + 1
  b(j) = b(j) - DOT_product( t(j+1:j+jj-1,j), b(j+1:j+jj-1) )
  b(j) = b(j)/t(j,j)
end do
GO TO 140

!        solve trans(t)*x=b for t upper triangular.

110 b(1) = b(1)/t(1,1)
do j = 2, n
  b(j) = b(j) - DOT_product( t(1:j-1,j), b(1:j-1) )
  b(j) = b(j)/t(j,j)
end do

140 return
end subroutine dtrsl


subroutine timer (time)
! Returns the time in seconds since midnight

real (dp), intent(OUT) :: time

! Local variable

integer :: t(8)

call DATE_AND_time(VALUES=t)
time = 3600._dp*t(5) + 60._dp*t(6) + t(7) + 0.001_dp*t(8)

return
end subroutine timer


end module L_BFGS_B
